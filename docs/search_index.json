[["index.html", "Shiny App Workflows Preface", " Shiny App Workflows Braeden Klaver Preface This document aims to provide a walkthrough on how to work within a shiny app workflow that leverages git/gitlab, package structure, shiny, and bslib. "],["git.html", "1 Git 1.1 Basic git workflow 1.2 Setting up Github or Gitlab projects 1.3 Collaborative git workflow 1.4 Using Git at the BCCDC 1.5 Basic Git Commands Summary 1.6 Additional Resources", " 1 Git Git is a free and open-source version control system. When used regularly and as intended, developers will have a full history of their project within a local repository. In addition to a historical log of changes to project files, git allows for project branching to support users to test/develop new code, while maintaining the master version for easy reversion. When users are ready to implement their new branch into the main codebase git can be used for merging files, whereby it tracks changes and ensures there are no conflicts between the main version and the new version. Beyond local usage, git is also supported by web-based repositories such as Github and Gitlab, where projects can be pushed, pulled, and cloned. These sites allow for easy collaboration with other developers and provide a number of user-friendly features that make working with git easier. NOTE In RStudio, git is accessed in the terminal or in the top right under the Git tab when Git has been initialized for the project. 1.1 Basic git workflow Step 1) Create a project. Step 2) Initialize git. git init Step 3) Check your project file status git status Step 4) Add a file to the local repo git add filename.R Step 5) Commit your change with a message git commit -m \"Add filename.R\" Step 6) Create a branch to test/develop code git branch test_branch Step 7) Go into that branch git checkout test_branch Step 8) Modify your code and repeat steps 3 and 4 Step 9) When ready merge branches git merge master test_branch TIP Branching is useful when you have a stable codebase that you do not want to break or if you are working collaboratively on a code base. You can create a branch to do development work and test new features until its ready for integration with the stable codebase or your coworkers. If you are developing something from scratch by yourself you may not need to use branching until later. 1.2 Setting up Github or Gitlab projects Ensure your profile is set up git config --global user.name \"Braeden Klaver\" git config --global user.email \"braeden.klaver@bccdc.ca\" WARNING When you create a new repository on github or gitlab it can cause issues if you create it with a README. It is recommended when creating new repositories to make sure they are a clean slate. 1.2.1 Pre-existing project on Github or Gitlab Step 1) In your terminal navigate to the folder you want to clone the project to cd \"U:/myprojects\" Step 2) Clone the project into that folder and give the project a name git clone http://lvmgenodh01.phsabc.ehcnet.ca/braeden.klaver/test.git myproject 1.2.2 Personal project without git Step 1) Open your R project Step 2) Initialize git git init Step 3) Create a project on Gitlab or Github Step 4) Connect your R project to that repository (should be the URL) git remote add origin http://lvmgenodh01.phsabc.ehcnet.ca/braeden.klaver/test.git Step 5) Add and commit your files git add . git commit -m \"Initial commit\" Step 6) Push your project to that repository git push -u origin --all 1.2.3 Personal project with Git Step 1) Open your R project Step 2) Connect your R project to that repository (should be the URL) git remote add origin http://lvmgenodh01.phsabc.ehcnet.ca/braeden.klaver/test.git Step 3) Push your project to that repository git push -u origin --all 1.3 Collaborative git workflow In addition to the basic workflow, when working with a web-based repository like Github or Gitlab there are additional steps you will need to take: Step 1) Pulling changes from the repository - your coworkers may have made changes! git pull Step 2) Follow the basic workflow (Section 1.1) Step 3) Pushing your changes to the repository - your coworkers will want to be up to date! git push or git push origin NOTE You have to use git push origin branch_name when working on a branch that isnt your main or master. 1.4 Using Git at the BCCDC 1.4.1 Git on Citrix Git is installed on citrix already, it can be initialized as described above or you can click a check box to create a git repository when creating a new project. TIP If you have a local R installation and youd like to work there but do not have git installed locally you can still leverage citrix R to use git for your projects. 1.4.2 Git locally If you want to use Git locally you will need to install it for your system. Typically, this will be the 64-bit windows version found here. Once it is downloaded you should be able to use git as described above in your local RStudio. NOTE The benefits of having a local installation of git is that if you primarily use your local RStudio you can access it directly through there rather than jumping to citrix. Additionally, you can use it to connect to repositories in Github, which is not possible on citrix. 1.4.3 Github Because Github is an external web-based repository there are some considerations for its use at the BCCDC. Currently, there are no formal guidelines on using it, for this reason using it for BCCDC-specific projects should be avoided. 1.4.4 Gitlab The BCCDC has a private Gitlab repository, which can be used for regular BCCDC projects within the scope set out in the guiding document. NOTE You can request access to Gitlab via this form. 1.4.5 Suggested project workflow Working with git tracked projects requires you to have your own local repository. For this reason, it is recommended to keep this repository in your U:/ drive. In addition, we would recommend having another local repository in the O:/ drive, which would be dedicated to running pipelines or deploying apps and not for development work. WARNING Some project data may not be permitted on your U:/ drive, therefore ensure your code is loading that data from an appropriate location. 1.5 Basic Git Commands Summary Command Description git init Initialize git for the directory git status Check the status of files in the directory (eg. are they being tracked, have they been modified) git add Stage a file for commit git rm Remove a file staged for commit git commit Commit your changes git branch Create a branch for development work git checkout Checkout a branch to work within git merge Merge two branches together git pull Pull the most up-to-date repository from a remote (ie. Github or Gitlab) git push Push your changes to a remote repository (ie. Github or Gitlab) NOTE There are many other functions that you can use in git beyond those listed above, however, these give you the tools to get started. 1.6 Additional Resources Mike Kuos Git Tutorial Git Playground NOTE The Git Playground does not work on Microsoft Edge! Try it on Google Chrome. "],["package-development.html", "2 Package Development 2.1 Package Structure 2.2 Loading devtools and usethis 2.3 load_all function 2.4 The DESCRIPTION file 2.5 Documenting your functions 2.6 The NAMESPACE 2.7 The README file 2.8 Organizing your scripts 2.9 Using data in a package 2.10 Additional Resources", " 2 Package Development In R, the fundamental unit of shareable code is the package. A package bundles together code, data, documentation, and tests, and is easy to share with others. But packages are useful even if you never share your code. As Hilary Parker says in her introduction to packages: Seriously, it doesnt have to be about sharing your code (although that is an added benefit!). It is about saving yourself time. Organising code in a package makes your life easier because packages come with conventions. For example, you put R code in R/, you put tests in tests/ and you put data in data/. These conventions are helpful because: They save time  you dont need to think about the best way to organise a project, you can just follow a template. Standardised conventions lead to standardised tools  if you buy into Rs package conventions, you get many tools for free. 2.1 Package Structure In an R package or R project structured as a package the typical files and folders will be (locally, you can consult your Files pane): path type description .Rbuildignore file Lists files that we need to have around but that should not be included when building the R package from source. .gitignore file Tells Git to ignore some standard, behind-the-scenes files created by R and RStudio. DESCRIPTION file Provides metadata about your package. NAMESPACE file Declares the functions your package exports for external use and the external functions your package imports from other packages. R/ folder the business end of your package. It will soon contain .R files with function definitions. 2.2 Loading devtools and usethis The devtools package is fundamental for developing packages, it comes with a suite of incredibly powerful functions. In addition, it comes with the required package usethis, which compliments the devtools package with another suite of functions required to properly build packages. library(devtools) 2.3 load_all function In a package or project structured as a package you are typically making functions that are stored in the R/ folder. In a standard project you may be familiar with the use of source(\"R/myfunction.R\") to load or run a script. However, devtools allows us to easily run/load all of our project contents with one simple function call: devtools::load_all() This does a few main things: Loads/runs your scripts located in the R/ folder Loads data stored in your data folder Loads other package objects Loads package dependencies listed in the DESCRIPTION file NOTE One main difference is that these functions and data that have been loaded will not appear in the environment, even though they are available. This is similar to when we load a package, such as library(tidyverse), we are now able to use functions such as mutate even though they dont appear in our environment. 2.4 The DESCRIPTION file The DESCRIPTION file provides metadata for your package. Some key pieces of this metadata include the description of the project and the dependencies. If your project doesnt have a DESCRIPTION file you can easily add one using usethis: usethis::use_description() You can manually edit this file or alternatively add certain elements using usethis. For example adding dependencies: usethis::use_package(&#39;dplyr&#39;) NOTE After creating a DESCRIPTION file in your project you will automatically enter package development mode. Read more! 2.5 Documenting your functions At some point we have all used the help functions in R by easily calling something like ?mutate. This requires special documentation which is stored in path such as man/mutate within the package. To do this for ourselves we have to use something called roxygen2, which helps create these handy help windows. To do this with your functions you can open your function script, place the cursor somewhere within the function and then do Code &gt; Insert roxygen skeleton, which will create a basic skeleton to fill out such as this: #&#39; Split a string #&#39; #&#39; @param x A character vector with one element. #&#39; @param split What to split on. #&#39; #&#39; @return A character vector. #&#39; @export #&#39; #&#39; @examples #&#39; x &lt;- &quot;alfa,bravo,charlie,delta&quot; #&#39; strsplit1(x, split = &quot;,&quot;) strsplit1 &lt;- function(x, split) { strsplit(x, split = split)[[1]] } Now, one more step is needed. We must use devtools to automatically create that man/function and update our NAMESPACE file like so: devtools::document() Read more! 2.6 The NAMESPACE The NAMESPACE file is an automatically generated and maintaind file by R, this should not be manually modified. It is filled out depending on the roxygen2 comments left in your scripts and is updated, as described above, by using devtools::document(). It informs the package what contents should be exported when building the package, as well as what needs to be imported (package dependencies) for the package to run. Read more! 2.7 The README file The README file is a very useful document that can help provide context, general information, and usage insight to users. In addition, when knitted, README files are formatted to appear as nice markdown documents in Github and Gitlab. To get a README file started in a project all that you need to do is: usethis::use_readme_rmd() NOTE Remember, you have to knit your README in order to produce a .md file version of it, which will be directly used in places like Github or Gitlab. 2.8 Organizing your scripts The file name should be meaningful and convey which functions are defined within. While youre free to arrange functions into files as you wish, the two extremes are bad: dont put all functions into one file and dont put each function into its own separate file. Organizing.principle Comments One function Defines exactly one function, thats not particulary large, but doesnt fit naturally into any other .R file Main function plus helpers Defines the user-facing function, a method, and private helpers Family of functions Defines a family of functions, all documented together in a big help topic, plus private helpers TIP Another file you often see in the wild is R/utils.R. This is a common place to define small utilities that are used inside multiple package functions. Since they serve as helpers to multiple functions, placing them in R/utils.R makes them easier to re-discover when you return to your package after a long break. 2.9 Using data in a package Traditionally, data in a package is stored in the data/ folder. The data there will be saved in a specific data form that will make it available when you run devtools::load_all(). To store data within a package like this you need to run: usethis::use_data(df) 2.10 Additional Resources R Package Manual "],["shiny.html", "3 Shiny 3.1 Shiny App Structure 3.2 UI 3.3 Server 3.4 Dynamic UI 3.5 Basic example 3.6 Deploying to shinyapps.io 3.7 Packaging a Shiny App 3.8 Additional Resources", " 3 Shiny Shiny is an R package that allows you to easily create rich, interactive web apps. Shiny allows you to take your work in R and expose it via a web browser so that anyone can use it. Shiny makes you look awesome by making it easy to produce polished web apps with a minimum amount of pain (but there will be some pain). 3.1 Shiny App Structure Shiny apps are composed of two main elements: UI: This is where you define the layout and appearance of your app, including sliders, plots, tabs, etc. The server: This is where you connect your UI components using logic behind the scenes to drive app behaviour. These two elements are combined to render a shiny app by calling shiny::shinyApp(ui = ui, server = server). 3.2 UI 3.2.1 Setting up the UI To create a shiny app you must create a UI. Traditionally, in shiny you do this using the functions shiny::fluidPage() or shiny::navbarPage(). The UI will contain elements such as calls to CSS stylings, overall UI design, inputs, and outputs. 3.2.2 Layouts One of the main things you will set up in the UI is the overall layout and theme. Shiny gives you multiple tools to craft your layout including: Sidebars Page Rows and columns Tabs Navigation lists and bars Figure 3.1: Structure of a basic app with sidebar Figure 3.2: The structure underlying a simple multi-row app 3.2.3 Themes Beyond the layout, you can also set a theme for your app. Currently, the easiest way to do this is to use the bslib package and set the theme by calling bslib::bs_theme(). There are a number of preset themes you can use, but you are also free to customize your own theme using this function. Read more on themes here. You can further tweak your apps look by using custom CSS stylings and by incorporating html code into your UI call. Read more about that here. 3.2.4 UI Inputs There are a number of inputs that you can use in shiny apps such as shiny::radioButtons(), shiny::selectInput(), shiny::actionButton(), and shiny::dateRangeInput(). These allow users to interact and dictate what appears in our app. Check out the all of the potential inputs here. These functions all share a two main arguments: inputID: This is the identifier used to connect the front end with the back end; if your UI has an input with ID name, the server function will access it with input$name. label: This is used to create a human-readable label for the control (ie. Select Geography). NOTE The inputId has two constraints: It must be a simple string that contains only letters, numbers, and underscores (no spaces, dashes, periods, or other special characters allowed!). Name it like you would name a variable in R. It must be unique. If its not unique, youll have no way to refer to this control in your server function! Read more! 3.2.5 UI Outputs In the UI we can also specify the outputs that wed like to include, for example plots, text, or tables; check out the cheatsheet for a list of Output() functions. In essence, these are placeholders, which will be filled in based on what we define in our server. Similar to inputs, we must also specify an outputID as the first argument. Read more! 3.3 Server On the server side, we build the logic that will power our app. Specifically, we need to fill our outputs and link them to the corresponding inputs if required. We do this by using a different suite of functions that will dictate what we fill our outputs with and using reactivity elements to link inputs to outputs. 3.3.1 Server Inputs Inputs are essentially data sent from the browser (ie. UI) to the server, which can be accessed by calling input$inputID. Because these are dictated on the browser side, these values are not modifiable (ie. they are read-only) within the server. The other important point about inputs is we inherently want to use them in a reactive context; in other words, we want to have logic that reacts to user input to drive behaviour on the backend to cause some kind of update to the frontend browser. More on this in section 3.3.3. Read more! 3.3.2 Server Outputs Similar to inputs we refer to outputs using their output IDs by calling output$outputID. However, as you may have guessed, instead of receiving inputs from the browser, we are providing outputs to fill in the UI placeholders. Outputs are always created using render functions, these may be wrapped in in reactive statements so that they update depending on inputs or they can be stand alone outputs that arent connected to any inputs. Read more! 3.3.3 Reactivity Reactivity is what brings everything together in an app. This is where we can use user inputs to update UI and outputs. There are many different types of reactive functions for different purposes; you can make UI and ouputs update in real time, when you click a button, or under other conditions! This is called declarative programming when you set certain constraints and let the program (the server logic) determine when to execute under those constraints. Interestingly, shiny operates lazily, in other words, it will only do the minimum work required to get the job done and only when it has to. We are basically telling shiny to: Ensure there is a sandwich in the refrigerator whenever I look inside of it Figure 3.3: The different reactive functions and how they operate. Read more! 3.3.4 Execution order Prepare yourself, this is where we begin to flip all of our coding knowledge on its head. Unlike regular scripts where we expect R to execute things orderly, line by line, shiny server logic doesnt function this way.. Instead, shiny will only execute specific lines of the server when it has what it needs for that line. For example: This: server &lt;- function(input, output, session) { output$greeting &lt;- renderText(string()) string &lt;- reactive(paste0(&quot;Hello &quot;, input$name, &quot;!&quot;)) } will result in the same output as this: server &lt;- function(input, output, session) { string &lt;- reactive(paste0(&quot;Hello &quot;, input$name, &quot;!&quot;)) output$greeting &lt;- renderText(string()) } TIP Its still recommended to have things in order to avoid confusion. But I think its an important thing to realize, because it highlights what is truly going on in the background and what makes shiny lazy. 3.4 Dynamic UI We wont dive too deeply into dynamic UI elements. They essentially function as typical UI inputs, however, they can be used to update the UI by other inputs in a reactive function. This is similar to how we can use inputs to update outputs, except in this case the output is a UI element. Read more! 3.5 Basic example 3.5.1 Set up First we need to do some prep before we build our app. Lets load our libraries: library(shiny) library(bslib) library(datasets) library(tidyverse) NOTE This is also where we would load datasets, set up global variables, and add paths if we need them for the app. Because this app is super simple we will just load our libraries. 3.5.2 Build the UI Lets create a simple UI with shiny::navbarPage() so we have tabs up top, well make one dropdown menu, a couple of plots side by side, and a table that shows the data that is being used in the plots. library(magrittr) ui &lt;- shiny::navbarPage( # Let&#39;s set up our title for the page title = &#39;Appy Hour&#39;, # Create a drop down list of the flower species shiny::selectInput( &#39;species&#39;, label = &#39;Select Species:&#39;, choices = c( unique( datasets::iris$Species ) ) ), # Set up our first tab, which will be for our plot shiny::tabPanel( title = &#39;Plot&#39;, # Let&#39;s make two plots but I want them side-by-side so we need to use fluidRow() shiny::fluidRow( # Within our fluidRow we want two columns that are evenly split # (remember 12 is the whole width) shiny::column( 6, shiny::plotOutput( outputId = &#39;plot1&#39; ) ), shiny::column( 6, shiny::plotOutput( outputId = &#39;plot2&#39; ) ) ) ), # Set up our second tab, which will be for our table shiny::tabPanel( &#39;Table&#39;, shiny::tableOutput( outputId = &#39;table1&#39; ) ) ) 3.5.3 Build the server Now lets connect everything. We need to use a reactive function to tell shiny to update our plots and table when a new flower species is selected. We also need to fill our plot and table placeholders with render functions. server &lt;- function(input, output, session) { # We need to set up a reactive wrapper, given we are only changing our plot # and table as a result of the change of the input # for our species the observeEvent() should work perfectly. shiny::observeEvent( input$species, { # Filter our data based on the inputs from the UI data &lt;- datasets::iris %&gt;% dplyr::filter( Species == input$species ) # Then because we have outputs we need the corresponding # render functions (plot and table) and create our outputs # within those and assign them to the placeholders in the UI output$plot1 &lt;- shiny::renderPlot( plot(data$Petal.Length, data$Petal.Width) ) output$plot2 &lt;- shiny::renderPlot( plot(data$Sepal.Length, data$Sepal.Width) ) output$table1 &lt;- shiny::renderTable( data ) } ) } NOTE Remember, the server function requires the same three arguments everytime: input, output, and session. 3.5.4 Putting it all together Now were finally ready to deploy locally! shiny::shinyApp(ui, server) 3.6 Deploying to shinyapps.io At the BCCDC we have a shinyapps.io account that allows us to publish our apps to their servers. We can set these to be publically viewable, as well as private. Typically, privately deployed apps are for development purposes or previewing prior to public release. To deploy the app you just need to call two functions like so: rsconnect::setAccountInfo( name = &#39;bccdc&#39;, token = &#39;07A000A33C5EF3D9EDAA3D1CA53339EF&#39;, secret = &#39;C2XOcD2ib8Kl2j07icXz9BnZc7DnwKxm9z7PJEz2&#39; ) rsconnect::deployApp( appName = &quot;myApp&quot;, appId = &quot;This ID gets generated after the initial push to shiny servers&quot;, appDir = getwd(), account = &#39;bccdc&#39;, upload = T, logLevel = &#39;verbose&#39;, appVisibility = c(&quot;public&quot;, &quot;private&quot;), forceUpdate = TRUE ) 3.7 Packaging a Shiny App Using package structure for a shiny app gets your toes into the water of package development. Its a long way from a complete package, but its still useful because it activates new tools that make it easier to work with larger app and provides you with standard conventions that can be used across projects. 3.7.1 Put all R code in the R/ directory Because we are going to be working in an app-package we need to create an R/ directory. This is where we will keep all of the core R code components that will build our app. As a reminder, in a package we are leveraging useful tools like devtools::load_all() (See section 2.3), which will load/run all of the code in the R/ directory. 3.7.2 Write a function that starts your app As mentioned in section 3.1, we need three primary pieces to create an app: ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) Now, to begin converting our project to a package-app we must wrap these three things into a function: myApp &lt;- function(...) { ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) } NOTE The function you create shouldnt need any arguments, all that we will use this for is to easily run our app locally and set it up for easy deployment later by simply calling myApp(). 3.7.3 Save your data to the data/ directory We may have some datasets or lists that we use in our app that arent routinely updated. These are perfect candidates to convert into .rda files using the handy function usethis::use_data() that we talked about in section 2.9. These will automatically be stored in the data/ directory and can be easily called directly after running load_all(). TIP Good candidates for us include things like crosswalk files for health geographies, age categories, and lists (domains, diseases, regions). 3.7.4 Create an inst/ directory The inst/ directory is where we can store other raw datasets that are more subject to change, for example the data used to feed our apps that comes from external pipelines. There is no standard convention so you can name things as you please, but common usage includes folders named inst/extdata or inst/ext to store these datasets. NOTE To load data we need to use system.file() to point to our datas location, as well as setting the package arugment to our projects name. myApp &lt;- function(...) { read.csv(system.file(&quot;extdata&quot;, &quot;mydata.csv&quot;, package = &quot;myApp&quot;)) ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) } Notice that our package-app automatically knows to look in our inst/ folder? 3.7.5 Create a www/ directory This directory is where you can store some of the other non-script or data components to the app such as CSS stylings or images. There are no rules to this but a suggestion would be to have a www/css and www/images sub-directory scheme for your app. TIP If you want to call files from within these sub-directories (eg. href = \"css/style.css\") you will need to tell your app where they are: myApp &lt;- function(...) { shiny::addResourcePath(&quot;css&quot;, file.path(getwd(), &quot;www/css&quot;)) shiny::addResourcePath(&quot;images&quot;, file.path(getwd(), &quot;www/images&quot;)) ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) } 3.7.6 Create a DESCRIPTION file Because we are working in a package environment one of the critical components will be our DESCRIPTION file, which was discussed in section 2.4. Normally when you deploy an app, the rsconnect package automatically figures out all of the packages your code uses. But because we are making a package-app with a DESCRIPTION file, it requires you to explicitly specify them. The easiest way to do this is to call usethis::use_package(). Youll need to start with shiny and pkgload: usethis::use_package(&quot;shiny&quot;) usethis::use_package(&quot;pkgload&quot;) 3.7.7 Deploying your app-package One of the final pieces to setting up your app-package is the app.R script. This is what will be used when we go to deploy our app to the server and contains two simple but important lines of code: pkgload::load_all(&quot;.&quot;) myApp() WARNING Although this is an R script, we DO NOT place this under our R/ directory. This would result in an infinite loop when running load_all() due to the load_all() function in the script! Therefore place this at the top-level of your project directory. Read more! 3.7.8 Workflow Putting your app code into the package structure unlocks a new workflow: Re-load all code in the app with Cmd/Ctrl + Shift + L. This calls devtools::load_all() which automatically saves all open files, source()s every file in R/, loads all datasets in data/ then puts your cursor in the console. Re-run the app with myApp(). Read more! 3.8 Additional Resources Shiny Manual Shiny Cheatsheet "],["bslib.html", "4 bslib 4.1 Fundamentals 4.2 Layouts 4.3 Cards 4.4 Sidebars 4.5 Value boxes 4.6 Tooltips and Popovers 4.7 Themes 4.8 Using Shiny Info 4.9 Advanced Example with bslib 4.10 Additional Resources", " 4 bslib The bslib R package provides a modern UI toolkit that builds on the shiny package. In summary, bslib facilitates: Creation of delightful and customizable Shiny dashboards. UI components (e.g., cards, value boxes, sidebars, etc). Custom theming of Shiny apps. install.packages(&quot;bslib&quot;) Figure 4.1: Example of a bslib dashboard 4.1 Fundamentals 4.1.1 Pages One of the core features of bslib is the use of pages/tabs. To build an app this way bslib makes it easy by using the bslib::page_navbar() function to create child tabs with bslib::nav_panel(). Additionally, bslib apps tend to rely on sidebars so many functions, including bslib::page_navbar(), have a built in sidebar argument that you can fill using bslib::sidebar(). Figure 4.2: Example of a bslib dashboard with a page layout. 4.1.2 Cards Another core feature of bslib apps is the card(). Apps built using bslib will almost always use cards, these are essentially containers that hold content in an organized way that make it really easy for users to engage, understand, and navigate your app. Figure 4.3: Example of a bslib dashboard cards. 4.1.3 Content filling The last core concept to bslib is the way it is geared towards a filling layout, which means that contents are encouraged to grow/shrink to fit the browser window so that regardless of the resolution youre accessing the app it will adjust to fill it nicely. As a result, many functions have a fill argument; these are considered fillable containers. The child contents, a child in this case means it is wrapped by the parent function, will fill the parent feature when fill = TRUE, which is the default. When content goes beyond the screen resolution bslib will make the content scrollable. There is a lot to filling and its fundamental to bslib so it is recommended to read more about it here. Figure 4.4: Example of a plot filling a card and cards filling a page. 4.2 Layouts 4.2.1 Multi-page To create multiple pages (or tabs) you can use bslib::page_navbar(), where you can set the sidebar argument if you want a sidebar, as well as add pages (tabs) by calling bslib::nav_panel(). Beyond a sidebar and tabs you can also create additional space between elements on the tab bar using bslib::nav_spacer() and even add links using bslib::nav_item(). #A typical setup bslib::page_navbar( title = &quot;Interesting title&quot;, sidebar = bslib::sidebar(), bslib::nav_spacer(), bslib::nav_panel( &quot;Tab 1&quot;, bslib::card() ), bslib::nav_panel( &quot;Tab 2&quot;, bslib::card() ), bslib::nav_panel( &quot;Tab 3&quot;, bslib::card() ), bslib::nav_item( htmltools::tags$a( &quot;Title&quot;, href = &quot;https://myurl.com&quot; ) ) ) Read more! TIP Most of the apps you will build will likely be structured something like the above as bslib::page_navbar() is one of the primary functions for building apps, especially at the BCCDC. 4.2.2 Multi-panel Not only can we use tabs at the page level using bslib::page_sidebar(), we can also create them using any bslib::navset_*(). These are built to be outside the context of cards, but there are also some that create tabbed cards following the format of bslib::navset_card_*(). Check all of the options here. Read more! NOTE Personally, the most useful feature set from this is the use of tabs for cards using bslib::navset_card_*(). 4.2.3 Scrolling vs filling Both bslib::page_sidebar() and bslib::page_navbar() default to a filling layout (see Section 4.1.3). Sometimes this results in undesireable behaviour, you can combat this by setting bslib::card() heights using min_height to restrict how small a card gets or max_height to restrict how large a card will get: bslib::page_sidebar( title = &quot;Title&quot;, bslib::sidebar = bslib::sidebar(), bslib::card( min_height = 200 ), bslib::card( max_height = 200 ) ) Even further, you may not want the filling layout at all. To stop this you can set fill = FALSE which will default outputs to 400px (or whatever height you have specified) and will make the whole page scrollable instead: bslib::page_sidebar( title = &quot;Penguins dashboard&quot;, bslib::sidebar = bslib::sidebar(), fillable = FALSE, bslib::card() ) Read more! 4.2.4 Multi-column 4.2.4.1 bslib::layout_columns() Create column layouts easily using bslib::layout_columns(). Optional arguments include: col_widths which go up to 12 for each row. Beyond 12 cards will wrap to the next row. Negative values create an empty space. If not specified widths will be equally split. row_heights Numeric inputs are fractional units but fixed units are supported too. If not specified widths will be equal. ui &lt;- bslib::page_sidebar( bslib::layout_columns( col_widths = c(4, 8, -2, 8, -2), row_heights = c(1, 2), bslib::card(), bslib::card(), bslib::card() ) ) Figure 4.5: Example of bslib::layout_columns() Read more! 4.2.4.2 bslib::layout_column_wrap() When displaying multiple cards (or value boxes, etc) at once, its often most visually appealing to have them displayed in a grid-like layout where each card has the same height and width. This is the core principle of bslib::layout_column_wrap(), instead of specifying every columns width and every rows height like bslib::layout_columns(), we will give a width and height to apply to every card. Read more! Fixed columns Provide the width as width = 1/n where n is the number of columns. Columns will adjust to the window size to maintain the 1/n width: bslib::layout_column_wrap( width = 1/2, height = 300, bslib::card(), bslib::card(), bslib::card() ) Read more! Responsive number of columns Provide the width in any valid CSS unit like 200px. In this case, a two card layout will wrap to a new row when the window is less than 400 pixels wide (200px * 2 cards); beyond 400 pixels the cards will widen to equally fill the space: bslib::layout_column_wrap( width = &#39;200px&#39;, height = 300, bslib::card(), bslib::card(), bslib::card() ) Read more! Fixed column width If you dont want cards to fill the free space if the window goes beyond the total width of your cards then set the argument fixed_width = TRUE: bslib::layout_column_wrap( width = &#39;200px&#39;, height = 300, fixed_width = TRUE, bslib::card(), bslib::card(), bslib::card() ) Read more! Varying heights by row The default is to have all row heights equal. However, you can also allow row heights to be different set heights_equal = \"row\": bslib::layout_column_wrap( width = &quot;200px&quot;, heights_equal = &quot;row&quot;, bslib::card(), bslib::card(), bslib::card() ) Read more! Varying heights by cell Cards are considered fill items, which means they will adapt to fill space by default. This means that if one card has less content than the other cards in the row, it will still expand to fill that empty space. However, you can prevent this by specifying fill = FALSE in specific cards: bslib::layout_column_wrap( width = &quot;200px&quot;, bslib::card(), bslib::card(), bslib::card( fill = FALSE, #Here it is!!! card_header(&quot;Nothing much here&quot;), &quot;This is it.&quot; ) ) Read more! Varying widths If you still want specific cards to have different widths but you want the functionality of wrapping, you can set the width to NULL and provide a custom css grid layout like so: bslib::layout_column_wrap( width = NULL, height = 300, fill = FALSE, style = css(grid_template_columns = &quot;2fr 1fr 2fr&quot;), #second card has half the width as the other two bslib::card(), bslib::card(), bslib::card() ) Read more! Nested layouts You can also nest layout_column_wrap() within another layout_column_wrap() to create unique layouts. For example: bslib::layout_column_wrap( width = 1/2, height = 300, bslib::card(), bslib::layout_column_wrap( width = 1, heights_equal = &quot;row&quot;, bslib::bslib::card(), bslib::bslib::card() ) ) Read more! NOTE In terms of formatting bslib::layout_column_wrap() is easier and provides a clean uniform look. It is likely that you will use this over bslib::layout_columns() in most cases. 4.2.5 Mobile layout Filling layout for mobile devices is defaulted to FALSE. You can enable it by setting fillable_mobile = TRUE at the page level. You will want to set min_height for cards to prevent too much shrinkage. Read more! 4.3 Cards A bslib::card() is designed to handle any number of known card items (e.g., card_header(), card_body(), etc) as unnamed arguments (i.e., children). As well see shortly, card() also has some useful named arguments (e.g., full_screen, height, etc). Read more! 4.3.1 Card components bslib::card_header(): is where you can place contents in a header. This is a great place for your title and any icons! bslib::card_body(): is where you can place your main card contents. If you find yourself using bslib::card_body() without changing any of its defaults, consider dropping it altogether since it will be wrapped together into an implicit card_body() call anyways. bslib::card_footer(): is where you can place contents in a footer. This is a great place for any tooltips or popovers (see section 4.6). 4.3.2 Restricting growth By default, a card()s size grows to accommodate the size of its contents. Thus, if a card_body() contains a large amount of text, tables, etc., you may want to specify a height or max_height so it doesnt get too large. If the contents go beyond the max_height the card will become scrollable. Read more! TIP These things can be finnicky, you really need to feel it out for yourself and do a lot of testing. Also, setting the height helps with formatting on mobile, otherwise things can get a bit squishy. 4.3.3 Scrolling Although scrolling is convenient for reducing the amount of space required to park lots of content, it can also be a nuisance to the user. When the contents of a card go beyond the height of the screen bslib will automatically create a scroll bar for the card. To help reduce the need for scrolling, consider pairing scrolling with full_screen = TRUE (which adds an icon to expand the cards size to the browser window). Additionally, set the parent to fill = FALSE and the whole page will become scrollable, where you can then set the card height argument so that the content fits within the card without the need for scrolling. Read more! TIP Scrolling in cards can get a bit weird depending on the content. Id recommend always having full_screen = TRUE and comparing how scrolling the card feels compared to scrolling the page. Remember, this can differ between pages/tabs! 4.3.4 Filling outputs A card()s default behavior is optimized for facilitating filling layouts. More specifically, if a fill item (e.g., plotly_widget), appears as a direct child of a card_body(), it resizes to fit the card()s specified height Fill item(s) arent limited in how much they grow and shrink, which can be problematic when a card becomes very small. To work around this, consider adding a min_height or height on the card_body() container or alternatively turn fill to FALSE in the cards parent container (ie. layout_column_wrap()). Setting fill to FALSE will make the page scrollable and therefore wont force the cards to adjust to the screen size, meaning you can set the card height to fit the content into the card without the need for scrolling. Read more! card( height = 300, style = &quot;resize:vertical;&quot;, card_header(&quot;Plots that grow but don&#39;t shrink&quot;), card_body( min_height = 250, plotly_widget, plotly_widget ) ) 4.3.5 Other features There is a ton of functionality for cards that we dont necessarily need to dive deep on. These include: Multiple card bodies: You can also set up a card with multiple card bodies, which is useful for when you want a fillable item with a non fillable item or to have unique stylings. Read more! Multiple columns: Sometimes you may want multiple columns in your card, for this you can use bslib::layout_column_wrap() within a card body to format the layout of your outputs. Read more! Multiple cards: Again, as discussed in section 4.2.4.2 using bslib::layout_column_wrap() can also help format the layout of multiple cards. Read more! Multiple tabs: We have already discussed tabs in section 4.2.2, these can be useful within cards themselves. Read more! Sidebars: You can also create sidebars within a card using bslib::layout_sidebar(). Read more! and Read even more! Static images: You can also embed static images! Read more! Flexbox: Cards are all fillable because they are CSS flexbox containers. This means when you have inline tags (html tags) there is weird behaviour where each tag will appear on a new line. However, if you set fill = FALSE they will render inline. Read more! 4.4 Sidebars 4.4.1 Floating layout Easily create a floating layout with a sidebar using bslib::layout_sidebar(). This will align nicely with the main contents or can even be placed inside cards. bslib::layout_sidebar( sidebar = sidebar(&quot;Sidebar&quot;), &quot;Main contents&quot; ) Read more! 4.4.2 Filling layout If you prefer to have a sidebar that extends the whole length of the page then make sure you nest your bslib::layout_sidebar() inside of a bslib::page_fillage() function. bslib::page_fillable( bslib::layout_sidebar( sidebar = sidebar(&quot;Sidebar area&quot;), &quot;Main area&quot; ) ) Read more! 4.4.3 Multi-page layout If you want to use a single sidebar for multiple pages of an app you want to use the sidebar argument that is found in bslib::page_navbar() or bslib::navset_card_tab(). bslib::page_navbar( sidebar = bslib::sidebar(&quot;Sidebar&quot;), nav_panel(&quot;Page 1&quot;, &quot;Page 1 content&quot;), nav_panel(&quot;Page 2&quot;, &quot;Page 2 content&quot;) ) Read more! TIP This is one of the best options for setting up a sidebar as it is built in with the bslib::page_navbar() which you will likely be building your app with anyways! 4.4.4 Conditional and reactive updates Sometimes we want to have conditional contents in the sidebar that are based on the page/tab that has been selected. We can use bslib::conditionalPanel() inside of the sidebar argument in bslib::page_navbar()/bslib::navset_card_tab()/navset_tab_pill(). We just have to provide an id that we can reference in the bslib::conditionalPanel(): shinyApp( page_navbar( title = &quot;Conditional sidebar&quot;, id = &quot;nav&quot;, # the ID to reference in server and in the UI sidebar = sidebar( conditionalPanel( # &quot;input.nav&quot; is referencing our &quot;inputs&quot; and specifically the ID &quot;nav&quot; which we set above &quot;input.nav === &#39;Page 1&#39;&quot;, #when we are on &quot;Page 1&quot; show this content &quot;Page 1 sidebar&quot; ), conditionalPanel( &quot;input.nav === &#39;Page 2&#39;&quot;, &quot;Page 2 sidebar&quot; ) ), nav_panel(&quot;Page 1&quot;, &quot;Page 1 contents&quot;), # Note that we use the same name as in the conditionalPanel = &quot;Page 1&quot; nav_panel(&quot;Page 2&quot;, &quot;Page 2 contents&quot;) ), server = function(...) { # no server logic required } ) We can also set the sidebar to open up one specific pages: ui &lt;- page_navbar( title = &quot;Sidebar updates&quot;, id = &quot;nav&quot;, # the ID to reference in server and in the UI sidebar = sidebar( id = &quot;sidebar&quot;, # set the sidebar ID open = FALSE, &quot;Sidebar&quot; ), nav_panel( &quot;Page 1&quot;, # the name of the nav page &quot;Sidebar closed. Go to Page 2 to open.&quot; ), nav_panel( &quot;Page 2&quot;, &quot;Sidebar open. Go to Page 1 to close.&quot; ) ) server &lt;- function(input, output) { observe({ sidebar_toggle( #the server toggle id = &quot;sidebar&quot;, #the sidebar ID open = input$nav == &quot;Page 2&quot; #open when on page 2 ) }) } Read more! TIP Conditional arguments in the sidebar are useful if certain filters are only applicable to certain pages and having the sidebar hidden may be useful if the first page is an intro for example. 4.4.5 Additional sidebar features Here are even more things you can do with sidebars: Accordions: Within a sidebar you can create an accordion using bslib::accordion() that will be flush to the sidebar and is an easy way to group input controls in a drop-down style. Read more! Nested sidebars: If you want to get wild and have nested sidebars go for it! Read more! Styling: There are a handful of other arguments to further customize the look and feel if the sidebar layout. They allow for a specific background color (via bg), which is applied to the sidebar area and main content area respectively. Read more! 4.5 Value boxes A bslib::value_box() is a special kind of card designed for highlighting a value along with a title and a showcase placeholder (typically a bsicons icon). You can even have a plot as a backdrop to the value showcase. These can be standalone value boxes and they can also easily be inserted into cards! Figure 4.6: An example of value boxes. Read more! 4.6 Tooltips and Popovers Tooltips and popovers are useful for displaying information in a convenient and non-obtrusive way. Both require a trigger and a message. Tooltips are toggled via focus / hover whereas popovers are toggled via click. Here is an example of a tooltip: #Tooltip example bslib::actionButton( &quot;btn_tip&quot;, &quot;Focus/hover here for tooltip&quot; ) |&gt; bslib::tooltip(&quot;Tooltip message&quot;) Here is an example of a popover: #Popover example actionButton( &quot;btn_pop&quot;, &quot;Click here for popover&quot; ) |&gt; popover( &quot;Popover message&quot;, title = &quot;Popover title&quot; ) There is a lot of functionality with tooltips and popovers, above are the simple usages but you can read more intricate methods and see more examples here. TIP Popovers are much more persistent (i.e., harder to open/close), and thus should only be used over tooltips when further interaction may be needed. To put it another way, use tooltips for small read-only messages, and popovers when the user should be able to interact with the message itself. 4.7 Themes 4.7.1 Bootswatch themes Bootswatch themes are pre-packaged themes that can be applied using bslib::bs_theme(). Apply them easily within your UI code: bslib::page_sidebar( theme = bslib::bs_theme(bootswatch = &quot;minty&quot;) ) Read more! 4.7.2 Main colours and fonts Sometimes you may want to have a customized theme. This is also easy to set up using bslib::bs_theme() by setting the background colour (bg), foreground colour (fg), accent colours (primary, secondary, etc) and fonts (base_font, heading_font, code_font, etc). page_sidebar( title = &quot;My app&quot;, bs_theme( bg = &quot;#101010&quot;, fg = &quot;#FFF&quot;, primary = &quot;#E69F00&quot;, secondary = &quot;#0072B2&quot;, success = &quot;#009E73&quot;, base_font = font_google(&quot;Inter&quot;), code_font = font_google(&quot;JetBrains Mono&quot;) ), ... ) Read more! 4.7.3 Additional theming tools Beyond the pre-packaged themes and customizing colours and fonts there are other tools we can use for theming. These are less important and more niche, so we wont dive in here. Theming variables: More targeted theming of certain elements. Adding rules: Add css files or additional css rules directly in bs_theme. Utility classes: Adding css directly to shiny UI components like buttons, tabs, etc. Component support: Creating custom HTML components using sass. Dynamic theming: Real-time theming like dark mode toggling. 4.8 Using Shiny Info Because we are still using shiny as a base, we can use useful tools like getCurrentOutputInfo() to drive behaviour on the server side. For example, adding new labels or plots when a window meets a certain size. server &lt;- function(input, output, session) { output$plot_id &lt;- renderPlot({ info &lt;- getCurrentOutputInfo() if (info$height() &gt; 600) { # code for &quot;large&quot; plot } else { # code for &quot;small&quot; plot } }) } Read more! NOTE This is probably the most advanced you can get with shiny and bslib. When you begin to work with things at this level you will need to learn how to use things like browser() and inspecting the shiny web-page. This is a bit beyond what we are going to cover here but I thought Id introduce it. 4.9 Advanced Example with bslib 4.9.1 Build the UI Lets create a more advanced UI with bslib::page_navbar so we have tabs up top, a sidebar on the left, theme it for BCCDC, with 3 tabs: Tab 1 will be for a bit of an about filled with practically nothing because I just want to add more features and having this tab is the only way.. Tab 2 will be looking into population data for each state. Tab 3 will be cover some metrics on poverty at the county level. library(magrittr) # I need %&gt;%... # We will start with an htmltools::tagList() call because this allows # us to add multiple components together at once (ie. our css stylings before diving into the bslib setup) ui &lt;- htmltools::tagList( # I&#39;ve commented it out because you won&#39;t have access to the css file. # However, this is to provide you with an example of how you&#39;d include it if you had it # htmltools::tags$head( # htmltools::tags$link( # rel = &quot;stylesheet&quot;, # type = &quot;text/css&quot;, # href = &quot;css/dashboard_styling.css&quot;) # ), ## Now we can begin the bslib section with our handy page_navbar() bslib::page_navbar( # Set up the ID for our pages id = &quot;nav&quot;, # This will be the title for our app title = &quot;Midwest Population Dashboard&quot;, # How exciting... # Our BCCDC colour as the background bg = &quot;#004987&quot;, # Overall theme can just be something simple theme = bslib::bs_theme(version = 5), # Let&#39;s include underlines for our page tabs underline = TRUE, # We also want our window title to be related to the app&#39;s content # this is what appears in the tab on your browser. window_title = &quot;Midwest Population Dashboard&quot;, # Let&#39;s make this mobile friendly fillable_mobile = TRUE, # Sidebar ----------------------------------------------------------- # Here we go! Sidebar first # Make it not too wide, on the left hand side sidebar = bslib::sidebar( id = &quot;sidebar&quot;, width = 400, position = &quot;left&quot;, # Let&#39;s set it to not open and only open on page 2 and 3 open = FALSE, # Conditional state selection for 2nd and 3rd pages # Create a drop down list of the states shiny::conditionalPanel( # Here we tell it the conditions condition = &quot;input.nav == &#39;Population Profiles&#39; || input.nav == &#39;Poverty Profiles&#39;&quot;, # This is our selection drop down shiny::selectInput( &#39;state&#39;, label = &#39;Select State:&#39;, selected = &quot;Illinois&quot;, # I want them to be the full names but select based on acronym choices = list( &quot;Illinois&quot; = &quot;IL&quot;, &quot;Indiana&quot; = &quot;IN&quot;, &quot;Michigan&quot; = &quot;MI&quot;, &quot;Ohio&quot; = &quot;OH&quot;, &quot;Wisconsin&quot; = &quot;WI&quot; ) ) ), # conditional county selection for 3rd page # same thought process as above but this time # for one of the pages only shiny::conditionalPanel( condition = &quot;input.nav == &#39;Poverty Profiles&#39;&quot;, shiny::selectInput( &#39;county&#39;, label = &#39;Select County:&#39;, #Selected as NULL for now. selected = NULL, # To start we&#39;ll just pull the Illinois counties # we will update based on state selection in server choices = ggplot2::midwest %&gt;% dplyr::filter(state == &quot;IL&quot;) %&gt;% dplyr::pull(county)%&gt;% stringr::str_to_title() #they were all caps.. didn&#39;t like.. ) ), # At the bottom of the sidebar let&#39;s have a link to the info # on the midwest dataset just because shiny::actionButton( inputId = &quot;data_info&quot;, label = &quot;More on this dataset&quot;, icon = shiny::icon(&#39;circle-info&#39;), onclick = &quot;window.open(&#39;https://ggplot2.tidyverse.org/reference/midwest.html&#39;)&quot; ) ), # Page 1 ----------------------------------------------------------- # Some gibberish About section bslib::nav_panel( title = &quot;About&quot;, bslib::layout_column_wrap( width = 1, # intro card bslib::card( min_height = 750, bslib::card_header( #This is how you can add a nice icon next to your title shiny::h4(shiny::div(bsicons::bs_icon(&quot;list-task&quot;), &quot;About&quot;)) ), shiny::htmlOutput( &quot;about&quot; #output id right here!!! we&#39;ll fill it with text in the server ) ) ) ), # Page 2 ----------------------------------------------------------- # this will be at state level # two plots, one for population by county bar chart # second one can be pop by race at state level bslib::nav_panel( title = &quot;Population Profiles&quot;, bslib::layout_column_wrap( width = &quot;600px&quot;, # I don&#39;t want to fill otherwise the cards will be huge and therefore the plots will get # too big fill = FALSE, # Card 1 pop by county ------------------------------------------- bslib::card( full_screen = TRUE, # Let the people go full screen! height = 575, # Seems like a good enough height bslib::card_header( shiny::h4( shiny::div( bsicons::bs_icon(&quot;pin-map-fill&quot;), &quot;Top 10 Populated Counties&quot; ) ) ), # Add in our plot &#39;placeholder&#39;.. hey that&#39;s shiny!! shiny::plotOutput( outputId = &quot;county_pop&quot; ) ), # Card 2 pop by race state ------------------------------------------- # same thing here as above bslib::card( full_screen = TRUE, height = 575, bslib::card_header( shiny::h4( shiny::div( bsicons::bs_icon(&quot;people-fill&quot;), &quot;State Population by Race&quot; ), ) ), shiny::plotOutput( outputId = &quot;race_pop&quot; ) ) ) ), # Page 3 ----------------------------------------------------------- # this will be at the county level and will # have 4 metrics for poverty in value boxes bslib::nav_panel( title = &quot;Poverty Profiles&quot;, bslib::layout_column_wrap( width = 1/2, # we learned this! I think.. let me go back and check fill = TRUE, # Box 1 perc pov ------------------------------------------- bslib::value_box( title = &quot;Percentage in Poverty&quot;, ## Because we want this value box to be reactive to our selections ## we need to include a textOutput for our value that we&#39;ll fill in ## in the server! value = shiny::textOutput(&#39;perc_poverty&#39;), height = 300, theme = bslib::value_box_theme(bg = &quot;#fff&quot;, fg = &quot;#004987&quot;) # let&#39;s set the theme ), # Box 2 perc pov ------------------------------------------- # Same!!! but different metric bslib::value_box( title = &quot;Percentage of Children in Poverty&quot;, value = shiny::textOutput(&#39;perc_child_poverty&#39;), height = 300, theme = bslib::value_box_theme(bg = &quot;#fff&quot;, fg = &quot;#004987&quot;) ), # Box 2 perc pov ------------------------------------------- # Same!!! but different metric bslib::value_box( title = &quot;Percentage of Adults in Poverty&quot;, value = shiny::textOutput(&#39;perc_adult_poverty&#39;), height = 300, theme = bslib::value_box_theme(bg = &quot;#fff&quot;, fg = &quot;#004987&quot;) ), # Box 2 perc pov ------------------------------------------- # Same!!! but different metric bslib::value_box( title = &quot;Percentage of Elderly in Poverty&quot;, value = shiny::textOutput(&#39;perc_elder_poverty&#39;), height = 300, theme = bslib::value_box_theme(bg = &quot;#fff&quot;, fg = &quot;#004987&quot;) ) ) ), ## spaces everything after to far right because it looks nicer and ## I can make this example even more complicated bslib::nav_spacer(), ## create a little drop down menu for links to shiny and bslib bslib::nav_menu( title = &quot;References&quot;, # first order of business.. shiny bslib::nav_item( htmltools::tags$a( shiny::icon(&quot;code&quot;), htmltools::HTML(&quot;shiny&quot;), href = &#39;https://mastering-shiny.org/&#39;, target = &quot;_blank&quot; ) ), # second will be bslib bslib::nav_item( htmltools::tags$a( shiny::icon(&quot;palette&quot;), #that&#39;s an icon! htmltools::HTML(&quot;bslib&quot;), #This is our text href = &#39;https://rstudio.github.io/bslib/&#39;, #URL target = &quot;_blank&quot; #This means open the link in a new tab ) ) ) ) ) 4.9.2 Build the server Alright its time to connect everything together and make it reactive! server &lt;- function(input, output, session) { # Let&#39;s handle the sidebar opening on page 2 and 3 first shiny::observe({ bslib::toggle_sidebar( #the server toggle id = &quot;sidebar&quot;, #the sidebar ID open = input$nav != &#39;About&#39; #Do the opposite (ie open) when not on the about ) }) # Page 1 About ---------------------------------------- # Just to show you how to render text simply here.. output$about &lt;- shiny::renderUI( &quot;This is the about section, this tells you what the app is about.......&quot; ) # Page 2 Population ----------------------------------- ## we are only updating this page based on the state input ## so we can use observeEvent() shiny::observeEvent(input$state, { ## let&#39;s set up the data for the county plot first county_pop_dat &lt;- ggplot2::midwest %&gt;% dplyr::filter(state == input$state) %&gt;% # We use the input here dplyr::arrange(-poptotal) %&gt;% dplyr::mutate(county = factor(county, levels = county)) %&gt;% dplyr::top_n( 10, poptotal ) ## Render the plot output$county_pop &lt;- shiny::renderPlot( ggplot2::ggplot( county_pop_dat, ggplot2::aes( x = county, y = poptotal ) ) + ggplot2::geom_bar( stat = &quot;identity&quot;, fill = &quot;skyblue&quot; ) + ggplot2::labs( x = &quot;County&quot;, y = &quot;Population&quot; ) + ggplot2::scale_y_continuous(labels = scales::comma) + ggplot2::theme_minimal() + ggplot2::theme( axis.text.x = ggplot2::element_text(angle = 90, hjust = 1, size = 14), axis.title.x = ggplot2::element_text(size = 16), axis.title.y = ggplot2::element_text(size = 16), axis.text.y = ggplot2::element_text(size = 14) ) ) ## Next let&#39;s do the race pop plot ## same idea let&#39;s filter using the input$state race_pop_dat &lt;- ggplot2::midwest %&gt;% dplyr::filter(state == input$state) %&gt;% dplyr::select( state, county, popwhite, popblack, popamerindian, popasian, popother ) %&gt;% tidyr::pivot_longer( cols = c( &#39;popwhite&#39;, &#39;popblack&#39;, &#39;popamerindian&#39;, &#39;popasian&#39;, &#39;popother&#39; ), names_to = &quot;pop_type&quot;, values_to = &quot;population&quot; ) %&gt;% dplyr::summarise( population = sum(population), .by = c(&#39;pop_type&#39;) ) %&gt;% dplyr::mutate( pop_type = dplyr::case_when( pop_type == &#39;popwhite&#39; ~ &quot;White&quot;, pop_type == &#39;popblack&#39; ~ &quot;Black&quot;, pop_type == &#39;popother&#39; ~ &quot;Other&quot;, pop_type == &#39;popasian&#39; ~ &quot;Asian&quot;, pop_type == &#39;popamerindian&#39; ~ &quot;Native American&quot; ) ) %&gt;% dplyr::arrange(-population) %&gt;% dplyr::mutate( pop_type = factor(pop_type, levels = pop_type) ) ## plot this bad boy output$race_pop &lt;- shiny::renderPlot( ggplot2::ggplot( race_pop_dat, ggplot2::aes( x = pop_type, y = population ) ) + ggplot2::geom_bar( stat = &quot;identity&quot;, fill = &quot;skyblue&quot; ) + ggplot2::labs( x = &quot;Race&quot;, y = &quot;Population&quot; ) + ggplot2::scale_y_continuous(labels = scales::comma) + ggplot2::theme_minimal() + ggplot2::theme( axis.text.x = ggplot2::element_text(angle = 90, hjust = 1, size = 14), axis.title.x = ggplot2::element_text(size = 16), axis.title.y = ggplot2::element_text(size = 16), axis.text.y = ggplot2::element_text(size = 14) ) ) }) # Page 3 Poverty -------------------------------------- ## First let&#39;s update the dropdown menu for the county ## when we select a state using input$state shiny::observeEvent(input$state, { ## Filter for the counties for that state new_choices &lt;- ggplot2::midwest %&gt;% dplyr::filter(state == input$state) %&gt;% dplyr::pull(county) %&gt;% stringr::str_to_title() ## Now let&#39;s update the UI reactively! ## to do that we only need to reference that handy ID shiny::updateSelectInput( inputId = &#39;county&#39;, label = &#39;Select County:&#39;, selected = new_choices[1], #just select the first in the list choices = new_choices ) }) ## Next let&#39;s update the value boxes when the county changes ## but we also need to take into account that the state&#39;s have ## some overlapping county names so it needs to react to a change in either ## we can do this using observe() shiny::observe({ ## Here let&#39;s set a global variable to the currently selected ## state and county like so.. In observe() any reference to ## an input is recognized by shiny and therefore this reactive ## container will be re-ran.. lazily .. by shiny as a result. state_selection &lt;- input$state county_selection &lt;- input$county ## Now we use those to filter our data vb_data &lt;- ggplot2::midwest %&gt;% dplyr::mutate( county = stringr::str_to_title(county) ) %&gt;% dplyr::filter( state == state_selection, county == county_selection ) ## Lastly just update that text UI to include our metrics! output$perc_poverty &lt;- renderText({ paste0(round(vb_data$percbelowpoverty, 1), &quot;%&quot;) }) output$perc_child_poverty &lt;- renderText({ paste0(round(vb_data$percchildbelowpovert, 1), &quot;%&quot;) }) output$perc_adult_poverty &lt;- renderText({ paste0(round(vb_data$percadultpoverty, 1), &quot;%&quot;) }) output$perc_elder_poverty &lt;- renderText({ paste0(round(vb_data$percelderlypoverty, 1), &quot;%&quot;) }) }) } 4.9.3 Putting it all together Now were finally ready to deploy locally! shinyApp(ui, server) NOTE Phew that was a bit of a step up. But I hope that you can see how we are slowly building on our skills from the shiny package with bslib. 4.10 Additional Resources bslib Manual "],["modularization.html", "5 Modularization 5.1 Module Basics 5.2 Advanced inputs and outputs 5.3 Advising against single object modules 5.4 Examples from the PHMRSapp 5.5 Additional Resources", " 5 Modularization At the simplest level, a module is a pair of UI and server functions. The magic of modules comes because these functions are constructed in a special way that creates a namespace. So far, when writing an app, the names (ids) of the controls are global: all parts of your server function can see all parts of your UI. Modules give you the ability to create controls that can only be seen from within the module. This is called a namespace because it creates spaces of names that are isolated from the rest of the app. Shiny modules have two big advantages. Firstly, namespacing makes it easier to understand how your app works because you can write, analyse, and test individual components in isolation. Secondly, because modules are functions they help you reuse code; anything you can do with a function, you can do with a module. 5.1 Module Basics To showcase modularization lets look at a very simple app: ui &lt;- shiny::fluidPage( shiny::selectInput(&quot;var&quot;, &quot;Variable&quot;, names(datasets::mtcars)), shiny::numericInput(&quot;bins&quot;, &quot;bins&quot;, 10, min = 1), shiny::plotOutput(&quot;hist&quot;) ) server &lt;- function(input, output, session) { data &lt;- shiny::reactive(datasets::mtcars[[input$var]]) output$hist &lt;- shiny::renderPlot({ hist( data(), breaks = input$bins, main = input$var ) }, res = 96 ) } A module is very similar to an app, that is, they are composed of: A module UI function A server function These functions both require an id argument that will namespace the module. To begin creating a module you are going to look for UI/server pairs in your app and extract them out into paired UI/server functions! In our example, this will be our inputs and plot. Read more! NOTE You can test your modules by treating them like a standalone app! 5.1.1 Module UI First the UI module. There are two steps: Put the UI in a function with an id argument Wrap each existing id in a NS() function so that each previous id turns into NS(id, \"previous_id\") This would look like this for our example: histogramUI &lt;- function(id) { htmltools::tagList( shiny::selectInput(shiny::NS(id, &quot;var&quot;), &quot;Variable&quot;, choices = names(mtcars)), shiny::numericInput(shiny::NS(id, &quot;bins&quot;), &quot;bins&quot;, value = 10, min = 1), shiny::plotOutput(shiny::NS(id, &quot;hist&quot;)) ) } The UI components are wrapped in tagList(), which allows you to bundle components that can then be placed in other functions in the app code such as shiny::fluidRow(), bslib::layout_column_wrap() or bslib::sidebar(). You can also wrap them in shiny::fluidRow() or bslib::layout_column_wrap() in the function itself if youd prefer, though that can limit the reusability. There is another way to namespace within a UI function; if you only have one original ID, lets use the plot for our example, you can follow this format: histogramUI &lt;- function(id) { ns &lt;- shiny::NS(id) shiny::plotOutput( ns(&quot;hist&quot;) ) } Read more! 5.1.2 Module server The second part of this is the server function, which is also going to have an id argument. Inside of this function we call moduleServer() with the id arugment, and an additional function that looks like the typical server function: # your first line will look like this, you may have more # arguments, we&#39;ll look at that later histogramServer &lt;- function(id) { # your second line will always look like this shiny::moduleServer(id, function(input, output, session) { # you put your server code inside of this call data &lt;- shiny::reactive(datasets::mtcars[[input$var]]) output$hist &lt;- shiny::renderPlot({ hist(data(), breaks = input$bins, main = input$var) }, res = 96) }) } These two levels help distinguish the arguments between your module and the server function. It looks complex but this is how every module is set up, so its really a copy and paste scenario. Read more! NOTE moduleServer() takes care of the namespacing automatically, that is input$var and input$bins identifies the original namespaces from the UI section of the module where we had NS(id, \"var\") and NS(id, \"bins\"). This is because of the shared id argument in the functions, that we will connect when we implement them in our app. 5.1.3 Module testing Its good practice to test your module in a function that creates a simple app that only includes your module: histogramApp &lt;- function() { ui &lt;- shiny::fluidPage( histogramUI(&quot;hist1&quot;) ) server &lt;- function(input, output, session) { histogramServer(&quot;hist1&quot;) } shiny::shinyApp(ui, server) } NOTE Just like a regular app we need to link the UI and server using the same id name. This will be what allows the UI and server parts of the module to talk to eachother and identify the inputs and outputs. 5.1.4 Namespacing Lets circle back on namespacing. At this point of the example we have two separate namespacing situations: Inside of our module we have NS(id, \"var\"), NS(id, \"bins\"), and NS(id, \"hist\") Outside of our module in our app function we have id = 'hist1' Its important to realize here that the namespaces that are created inside a module only exist (ie. can be referred to) within the two module functions; in other words, a module is in essence a black box that cant be seen from outside of the module. This means that as an author of a module, you dont need to worry about conflicts with namespacing with other modules or with namespacing in the app UI or server. If youd like to refer to inputs from other places in the app in your module youll have to pass them to a module argument explicitly - well talk about this later. Read more! NOTE Note that the module UI and server differ in how the namespacing is expressed: In the module UI, the namespacing is explicit: you have to call NS(id, \"name\") every time you create an input or output. In the module server, the namespacing is implicit. You only need to use id in the call to moduleServer() and then Shiny automatically namespaces input and output so that in your module code input$name means the input with name NS(id, \"name\"). 5.1.5 Module naming conventions A standard convention for naming can be as follows: R/histogram.R holds all the code for the module. histogramUI() is the module UI. If its used primarily for input or output it can be called histogramInput() or histogramOuput() instead. histogramServer() is the module server. histogramApp() creates a complete app for interactive experimentation and more formal testing. Read more! 5.2 Advanced inputs and outputs Adding arguments beyond the id to the module UI gives greater control over the module, allowing you to use the same module in more places in your app. Unlike regular Shiny code, connecting modules together requires you to be explicit about inputs and outputs. Initially, this is going to feel tiresome and its certainly more work than Shinys usual free-form association. But modules enforce specific lines of communication for a reason: theyre a little more work to create, but much easier to understand, and allow you to build substantially more complex apps. Read more! 5.2.1 UI input and server output Lets look at an example from the book where we will have an additional argument in our input function and the server function returns a reactive value that we will use in a different element of the server. First set up the input function: # Two arguments, id as usual and a filter datasetInput &lt;- function(id, filter = NULL) { # Get list of df names for user selection names &lt;- ls(&quot;package:datasets&quot;) # If a filter is present then update the names in the list # accordingly if (!is.null(filter)) { # get the data to identify datasets vs matrices data &lt;- lapply(names, get, &quot;package:datasets&quot;) # filter for selection, &quot;dataset&quot; or &quot;matrix&quot; names &lt;- names[vapply(data, filter, logical(1))] } # Set up the UI selections for the list of names shiny::selectInput(shiny::NS(id, &quot;dataset&quot;), &quot;Pick a dataset&quot;, choices = names) } Then the server function: datasetServer &lt;- function(id) { # set up the usual shiny::moduleServer(id, function(input, output, session) { # The last expression in the function # will be the return value and return values # should always be inside a reactive() wrapper shiny::reactive(get(input$dataset, &quot;package:datasets&quot;)) }) } Finally putting it all together: # They included an argument in the larger app call # it makes sense for this small example but you would probably # call it in the UI itself.. at least I would datasetApp &lt;- function(filter = NULL) { ui &lt;- shiny::fluidPage( # Set up the input portion of the module datasetInput(&quot;dataset&quot;, filter = filter), # also include a placeholder for a table to show # the selected data from our module shiny::tableOutput(&quot;data&quot;) ) server &lt;- function(input, output, session) { # Set up the server, because it&#39;s giving us a reactive value # that we want to use in the table we need to do `&lt;-` assignment # just like we would normally in R data &lt;- datasetServer(&quot;dataset&quot;) # Now call this data in our table render output$data &lt;- renderTable(head(data())) } shinyApp(ui, server) } Read more! NOTE When you are returning a value in the server portion of your app thats reactive (ie. user input will impact it) you must assign it to a value in the environment, just like you would in typical R code. However, when you want to use that stored value you must refer to it like value() versus accessing its reactive form by calling just value. In the above example this is why we call the reactive data value as data() when rendering it into the table - we want the actual data not the reactive aspect of the data. 5.2.2 Server inputs Given that we work with both reactive and unreactive values in an app, it can be smart to set up simple error messages in your server modules to ensure that future users know what type of value is expected in a server argument: selectVarServer &lt;- function(id, data, filter = is.numeric) { # We need data to be reactive! stopifnot(shiny::is.reactive(data)) # We need the filter to be a non-reactive value! stopifnot(!shiny::is.reactive(filter)) shiny::moduleServer(id, function(input, output, session) { shiny::observeEvent(data(), { shiny::updateSelectInput(session, &quot;var&quot;, choices = find_vars(data(), filter)) }) shiny::reactive(data()[[input$var]]) }) } Read more! NOTE Another way to think about reactive or non-reactive values is when can the value change: is it fixed and constant over the life-time of the app, or is it reactive, changing as the user interacts with the app. 5.2.3 Modules inside of modules Modules can also be nested, in that you can call a module within another module. This makes sense if you have two components that are inherently tied together in your app. Here is an example from mastering shiny: # Because the example&#39;s goal is to allow users to select # a dataset and then select a variable from that dataset # it made sense to just combine the individual modules into a larger # module selectDataVarUI &lt;- function(id) { # Tag list for combining multiple components htmltools::tagList( # This is a dataset input selection datasetInput(shiny::NS(id, &quot;data&quot;), filter = is.data.frame), # This is to select the variable from the selected dataset selectVarInput(shiny::NS(id, &quot;var&quot;)) ) } selectDataVarServer &lt;- function(id, filter = is.numeric) { shiny::moduleServer(id, function(input, output, session) { # Here we pull the data based on the selection data &lt;- datasetServer(&quot;data&quot;) # and here we filter the data for the variable var &lt;- selectVarServer(&quot;var&quot;, data, filter = filter) var #return value }) } selectDataVarApp &lt;- function(filter = is.numeric) { ui &lt;- shiny::fluidPage( shiny::sidebarLayout( # Now there only needs to be a single call in the UI shiny::sidebarPanel(selectDataVarUI(&quot;var&quot;)), shiny::mainPanel(shiny::verbatimTextOutput(&quot;out&quot;)) ) ) server &lt;- function(input, output, session) { # and a single call in the server var &lt;- selectDataVarServer(&quot;var&quot;, filter) output$out &lt;- shiny::renderPrint(var(), width = 40) } shinyApp(ui, server) } Read more! 5.2.4 Multiple outputs Sometimes its useful for the modules server to return more than one value. You can easily do this the same way you would for a regular R function - return a list. The example from mastering shiny is: selectVarServer &lt;- function(id, data, filter = is.numeric) { stopifnot(shiny::is.reactive(data)) stopifnot(!shiny::is.reactive(filter)) moduleServer(id, function(input, output, session) { shiny::observeEvent(data(), { shiny::updateSelectInput(session, &quot;var&quot;, choices = find_vars(data(), filter)) }) list( # Return the name and the values of the variable name = shiny::reactive(input$var), value = shiny::reactive(data()[[input$var]]) ) }) } histogramApp &lt;- function() { ui &lt;- shiny::fluidPage(...) server &lt;- function(input, output, session) { data &lt;- datasetServer(&quot;data&quot;) # assign the list to X x &lt;- selectVarServer(&quot;var&quot;, data) # create a histogram using the values and title it with the # variable name histogramServer(&quot;hist&quot;, x$value, x$name) } shinyApp(ui, server) } Read more! WARNING The main challenge with this sort of code is remembering when you use the reactive form (e.g.x$value) vs.when you use its stored value (e.g.x$value()). Just remember that when passing an argument to a module, you want the module to react to the value changing which means that you have to pass the reactive, not its current value. However, if you want to display the actual current value you would pass the stored value. 5.3 Advising against single object modules When some people encounter modules for the first time, they immediately attempt to combine the module server and module UI into a single module object. However, in Shiny, UI and server are inherently disconnected; Shiny doesnt know which UI invocation belongs to which server session. You can see this pattern throughout Shiny: for example, plotOutput() and renderPlot() are connected only by shared id. Writing modules as separate functions reflects that reality: theyre distinct functions that are not connected other than through a shared id. This also allows you to make them more generalizable and allows for reactivity. For a full example read more here. 5.4 Examples from the PHMRSapp To ground some of our knowledge lets look at examples from our very own PHMRSapp. These arent necessarily perfect so try to think of ways you could improve them and test out your ideas! 5.4.1 Dropdown module First lets break down a simple module that helps create a dropdown menu. We will go over the module that currently exists in the PHMRSapp and then we can look at how wed improve it to make it better formatted to the mastering shiny documentation. Here is the original module: # For this module we first set up the UI # As always we include that id argument, but # we also have a label argument so we can customize # our menu title depending on what we&#39;re using it for dropdown_ui &lt;- function(id, label) { # Here&#39;s the alternative method, not needed for the other way ns &lt;- shiny::NS(id) # The dropdown function from shiny shiny::selectizeInput( ns(id), # we also could&#39;ve set this up by just doing shiny::NS(id, &quot;selections&quot;) shiny::h5(label), # here we use the label argument to title our menu choices = NULL, # chioces are set to null because they will be filled later for what we need options = list(allowEmptyOption = FALSE) # makes it so we don&#39;t have a blank option ) } # Now we set up the server end # again we have our id argument, but we also have our # choice_list which we can use to update our menu options dropdown_server &lt;- function(id, choice_list) { # the usual call to moduleServer() shiny::moduleServer( id, function (input, output, session) { # We will update our choices here and set # the selected to be the top choice in our # list by default shiny::updateSelectizeInput( session, id, choices = choice_list, selected = choice_list[[1]][1] ) # creating an empty list of reactive values that can be filled myreturn &lt;- shiny::reactiveValues() # set up the return to txt in a reactive container shiny::observe({ myreturn$txt &lt;- shiny::req(eval(parse(text = paste0(&quot;input$&quot;, id)))) }) return(myreturn) }) } # Finally, let&#39;s test it out dropdown_demo &lt;- function() { # Set our UI ui &lt;- shiny::fluidPage( # Call our module UI dropdown_ui( id = &quot;select&quot;, label = shiny::h5(&quot;Select an option:&quot;) ), # Let&#39;s create a text output to test our # module shiny::textOutput( &#39;select_text&#39; ) ) # server server &lt;- function(input, output, session) { # Call our server and set the choices list select &lt;- dropdown_server( id = &quot;select&quot;, choice_list = c( &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ) ) # Render our text output, which remember was stored in txt output$select_text &lt;- shiny::renderText(select$txt) } shinyApp(ui, server) } dropdown_demo() Alternatively, we can code it in a way that better reflects mastering shinys documentation: dropdown_ui &lt;- function(id, label) { shiny::selectizeInput( shiny::NS(id, &quot;select&quot;), # changed the id to the mastering shiny method shiny::h5(label), choices = NULL, options = list(allowEmptyOption = FALSE) ) } dropdown_server &lt;- function(id, choice_list) { shiny::moduleServer( id, function (input, output, session) { shiny::updateSelectizeInput( session, id, choices = choice_list, selected = choice_list[[1]][1] ) # We changed this to use a reactive container and call the select # input we set in the UI shiny::reactive(input$select) }) } # Finally, let&#39;s test it out dropdown_demo &lt;- function() { ui &lt;- shiny::fluidPage( dropdown_ui( id = &quot;select&quot;, label = shiny::h5(&quot;Select an option:&quot;) ), shiny::textOutput( &#39;select_text&#39; ) ) # server server &lt;- function(input, output, session) { select &lt;- dropdown_server( id = &quot;select&quot;, choice_list = c( &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ) ) # we call the actual value using select() to fill our text output # unlike the previous method output$select_text &lt;- shiny::renderText(select()) } shinyApp(ui, server) } dropdown_demo() 5.4.2 CSV Download Module Next lets look at a module that allows for a CSV to be downloaded: # UI set up, the typical id argument and we # add a label argument csv_download_ui &lt;- function(id, label) { # Alternative method, could use the standard if we wanted ns &lt;- shiny::NS(id) # for a download we just use a button shiny::downloadButton( outputId = ns(&#39;download&#39;), # setting the id label = label, # our download title icon = shiny::icon(&quot;download&quot;) # add in a download icon ) } # server setup, two arguments: one for the id, and one for # the data that will be downloaded csv_download_serv &lt;- function(id, data_name) { # the standard copy and paste start shiny::moduleServer( id, function(input, output, session){ # here is our download handler output$download &lt;- shiny::downloadHandler( # this is the format for the download handler filename = function() { # set up our file name paste0(data_name, &quot;.csv&quot;) }, # this is the format for the download handler as well content = function(file) { # Write the dataset to the `file` that will be downloaded write.csv(eval(parse(text = data_name)), file) } ) }) } # test ------------------------------------------------------------ download_demo &lt;- function() { ui &lt;- shiny::fluidPage( csv_download_ui(id = &quot;download&quot;, label = &quot;Download csv&quot;) ) # server server &lt;- function(input, output, session) { csv_download_serv(id = &quot;download&quot;, data_name = &quot;mtcars&quot;) } shinyApp(ui, server) } download_demo() 5.4.3 Domain select module This next module looks at doing something similar to the dropdown module: domain_list &lt;- list( &quot;Demographics&quot; = c(&quot;Population projection&quot;, &quot;Housing&quot;), &quot;Factors that affect health&quot; = c(&quot;Body mass index adult&quot;, &quot;Body mass index youth&quot;) ) # Setting up the UI with just an id argument # hmm.. there domain_select_ui &lt;- function(id) { # The other way! ns &lt;- shiny::NS(id) # Setting this up in a container # this is fine but also can restrict it&#39;s resuability in the future shiny::fluidRow( # Domain selection dropdown shiny::selectizeInput( ns(&quot;domain&quot;), &quot;Select domain&quot;, # the title choices = names(domain_list), # initial list selected = names(domain_list)[1] #the initial selection ), # Second dropdown for selection shiny::selectizeInput( ns(&quot;sub_domain&quot;), &quot;Select subdomain&quot;, # the title choices = NULL # empty because updating later on ) ) } ## Server setup, we are looking to link our top level selection with the lower level domain_select_server &lt;- function(id) { shiny::moduleServer( id, function (input, output, session) { # Update HSDA selectizeInput list when # a new domain is selected shiny::observeEvent(input$domain, { # Look at the list and extract the sub contents # based on the domain choices &lt;- domain_list[[input$domain]] # Update the sub domain list based on this selection shiny::updateSelectizeInput( session, &quot;sub_domain&quot;, choices = shiny::isolate(choices), # I&#39;m not sure we actually need this isolate() call.. try it without! server = FALSE, selected = choices[1] ) }) # return a list of values return &lt;- shiny::reactiveValues() shiny::observe({ return$domain &lt;- shiny::req(input$domain) return$sub_domain &lt;- shiny::req(input$sub_domain) }) return(return) }) } ## Test demo -------------------------------------------------- domain_select_demo &lt;- function() { ui &lt;- shiny::fluidPage( domain_select_ui( id = &quot;domain_select&quot; ), shiny::htmlOutput(&quot;domain&quot;), shiny::htmlOutput(&quot;sub_domain&quot;) ) # server server &lt;- function(input, output, session) { domain &lt;- domain_select_server( id = &quot;domain_select&quot; ) shiny::observeEvent(domain, { output$domain &lt;- shiny::renderText({domain$domain}) output$sub_domain &lt;- shiny::renderText({domain$sub_domain}) }) } shiny::shinyApp(ui, server) } domain_select_demo() 5.4.4 Sidebar select module Lastly, we can look at one of the more complex modules that looks to create conditional panels based on the geography selection: region_list &lt;- list( &quot;1 Interior&quot; = list( &quot;11 East Kootenay&quot; = list( &quot;111 Fernie&quot; = &quot;1110 Fernie&quot;, &quot;112 Cranbrook&quot; = &quot;1120 Cranbrook&quot; ), &quot;12 Kootenay Boundary&quot; = list( &quot;121 Kootenay Lake&quot; = &quot;1210 Kootenay Lake&quot;, &quot;122 Nelson&quot; = &quot;1220 Nelson&quot; ) ), &quot;2 Fraser&quot; = list( &quot;21 Fraser East&quot; = list( &quot;211 Hope&quot; = &quot;2110 Hope&quot;, &quot;212 Chilliwack&quot; = c(&quot;2120 South Chilliwack&quot;, &quot;2122 North Chilliwack&quot;) ), &quot;22 Fraser North&quot; = list( &quot;221 New Westminster&quot; = c(&quot;2211 New Westminster - East&quot;, &quot;2212 New Westminster - Central&quot;), &quot;222 Burnaby&quot; = c(&quot;2221 Burnaby Heights/Capital Hill&quot;, &quot;2222 Brentwood/Willingdon/Parkcrest&quot;) ) ) ) # UI set up sidebar_select_ui &lt;- function(id) { # You know the drill ns &lt;- shiny::NS(id) # Container wrapper shiny::fluidRow( #First level of the geography selection shiny::selectizeInput( ns(&quot;geography_level&quot;), &quot;Select geography level&quot;, choices = list( &quot;British Columbia&quot; = &quot;BC&quot;, &quot;Health Authority&quot; = &quot;HA&quot;, &quot;Health Service Delivery Areas&quot; = &quot;HSDA&quot;, &quot;Local Health Area&quot; = &quot;LHA&quot;, &quot;Community Health Service Area&quot; = &quot;CHSA&quot;) ), # Second level, this is for HA # we have a conditoinal panel as we only # want it to show up if we have a geography # level below BC shiny::conditionalPanel( condition = &quot;input.geography_level == &#39;HA&#39; || input.geography_level == &#39;HSDA&#39; || input.geography_level == &#39;LHA&#39; || input.geography_level == &#39;CHSA&#39;&quot;, ns = ns, shiny::selectizeInput( ns(&quot;HA&quot;), &quot;Select HA&quot;, # This is hard coded, means it&#39;s not reusable, we could&#39;ve # made this an argument to make reusable choices = names(region_list) ), ), # Third level, for HSDA # Anything HSDA or lower show this selection menu shiny::conditionalPanel( condition = &quot;input.geography_level == &#39;HSDA&#39;|| input.geography_level == &#39;LHA&#39; || input.geography_level == &#39;CHSA&#39;&quot;, ns = ns, shiny::selectizeInput( ns(&quot;HSDA&quot;), &quot;Select HSDA&quot;, choices = NULL, # we will update this later options = list(allowEmptyOption = FALSE) ) ), # Fourth level, for LHA # Anything LHA or lower show this menu shiny::conditionalPanel( condition = &quot;input.geography_level == &#39;LHA&#39; || input.geography_level == &#39;CHSA&#39;&quot;, ns = ns, shiny::selectizeInput( ns(&quot;LHA&quot;), &quot;Select LHA&quot;, choices = NULL, options = list(allowEmptyOption = FALSE) ) ), # Fifth level, for CHSA # Anything CHSA how this menu shiny::conditionalPanel( condition = &quot;input.geography_level == &#39;CHSA&#39;&quot;, ns = ns, shiny::selectizeInput( ns(&quot;CHSA&quot;), &quot;Select CHSA&quot;, choices = NULL, options = list(allowEmptyOption = FALSE) ) ), # A button for generating the profile # again this is geared for this app only, we could&#39;ve just had this outside # to make this function a bit more generalizable shiny::actionButton(ns(&quot;generate_profile&quot;), &quot;Generate Profile&quot;) ) } # Server set up time, standard id argument sidebar_select_server &lt;- function(id) { # The usual setup shiny::moduleServer( id, function (input, output, session) { # When we have an HA input we update the according HSDAs shiny::observeEvent(input$HA, { shiny::updateSelectizeInput( session, &quot;HSDA&quot;, choices = shiny::isolate(names(region_list[[input$HA]])), # Hmm.. again maybe we don&#39;t need this isolate(), we can test it! server = FALSE ) # When we have an HSDA input we update the according LHAs observeEvent(input$HSDA, { shiny::updateSelectizeInput( session, &quot;LHA&quot;, # Hard coded list again.. could be an argument then we can use it for other apps! choices = shiny::isolate(names(region_list[[input$HA]][[input$HSDA]])), server = FALSE ) # When we have an LHA input we update the according CHSAs shiny::observeEvent(input$LHA, { shiny::updateSelectizeInput( session, &quot;CHSA&quot;, choices = shiny::isolate(region_list[[input$HA]][[input$HSDA]][[input$LHA]]), server = FALSE) }) }) }) # Create a list of values when we click the button! sidebar_input &lt;- shiny::eventReactive(input$generate_profile, { list( geography_level = input$geography_level, ha = input$HA, hsda = input$HSDA, lha = input$LHA, chsa = input$CHSA) }) # return values for use in other parts of our app! # Remember we actually have other ways to return lists # that might make this a bit more clean... interesting # how there are different ways to do the same thing! sidebar_return &lt;- shiny::reactiveValues() observeEvent(input$generate_profile, { sidebar_return$level &lt;- shiny::req({ sidebar_input()$geography_level }) sidebar_return$ha &lt;- shiny::req({ sidebar_input()$ha }) sidebar_return$hsda &lt;- shiny::req({ sidebar_input()$hsda }) sidebar_return$lha &lt;- shiny::req({ sidebar_input()$lha }) sidebar_return$chsa &lt;- shiny::req({ sidebar_input()$chsa }) }) return(sidebar_return) } ) } # Test! ------------------------------------ sidebar_select_demo &lt;- function() { ui &lt;- fluidPage( sidebar_select_ui(id = &quot;region_select&quot;), textOutput(&quot;level&quot;), textOutput(&quot;ha&quot;), textOutput(&quot;hsda&quot;), textOutput(&quot;lha&quot;), textOutput(&quot;chsa&quot;), ) # server server &lt;- function(input, output, session) { # If we returned a different list format than the one up there # we probably wouldn&#39;t need these initial `myvals &lt;-` or `mytxt &lt;-`. #Something to consider! myvals &lt;- reactiveValues() mytxt &lt;- reactiveValues() mytxt &lt;- sidebar_select_server(id = &quot;region_select&quot;) observe({ myvals$level &lt;- mytxt$level myvals$ha &lt;- mytxt$ha myvals$hsda &lt;- mytxt$hsda myvals$lha &lt;- mytxt$lha myvals$chsa &lt;- mytxt$chsa output$level &lt;- renderText({ myvals$level }) output$ha &lt;- renderText({ myvals$ha }) output$hsda &lt;- renderText({ myvals$hsda }) output$lha &lt;- renderText({ myvals$lha }) output$chsa &lt;- renderText({ myvals$chsa }) }) } shinyApp(ui, server) } sidebar_select_demo() 5.5 Additional Resources Shiny Modules "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
