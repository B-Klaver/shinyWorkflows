[["shiny.html", "4 Shiny 4.1 Shiny App Structure 4.2 UI 4.3 Server 4.4 Dynamic UI 4.5 Basic example 4.6 Deploying your app 4.7 Packaging a Shiny App 4.8 Additional Resources", " 4 Shiny Shiny is an R package that allows you to easily create rich, interactive web apps. Shiny allows you to take your work in R and expose it via a web browser so that anyone can use it. Shiny makes you look awesome by making it easy to produce polished web apps with a minimum amount of pain (but there will be some pain). 4.1 Shiny App Structure Shiny apps are composed of two main elements. The UI: This is where you define the layout and appearance of your app, including sliders, plots, tabs, etc. The server: This is where you connect your UI components using logic behind the scenes to drive app behaviour. These two elements are operationalized by calling shinyApp(ui = ui, server = server) 4.2 UI 4.2.1 Setting up the UI To create a shiny app you must create a UI. Traditionally, in shiny you do this using the function fluidPage(). The UI will contain elements such as calls to CSS stylings, overall UI design, inputs, and outputs. 4.2.2 Layout and themes In the UI one of the main things you will do is to set up the general look of the app. Shiny gives you multiple tools to craft your layout including: Sidebars Page Rows and columns Tabs Navigation lists and bars Beyond the layout, you can also set a theme for your app. Currently, the easiest way to do this is to use the bslib package and set the theme by calling bslib::bs_theme(). There are a number of preset themes you can use, but you are also free to customize your own theme using this function. Read more on themes here. You can further tweak your apps look by using custom CSS stylings and by incorporating html code into your UI call. Read more about that here. 4.2.3 Inputs There are a number of inputs that are incredibly useful in shiny apps such as radioButtons(), selectInput(), actionButton(), and dateRangeInput(). These allow users to interact with our app to dictate what appears in our app. Check out the all of the potential inputs here These functions all share a two main arguments: inputID: This is the identifier used to connect the front end with the back end: if your UI has an input with ID name, the server function will access it with input$name. label: This is used to create a human-readable label for the control (ie. Select Geography). NOTE The inputId has two constraints: It must be a simple string that contains only letters, numbers, and underscores (no spaces, dashes, periods, or other special characters allowed!). Name it like you would name a variable in R. It must be unique. If its not unique, youll have no way to refer to this control in your server function! Read more! 4.2.4 Outputs In the UI we can also specify the outputs that wed like to include, for example plots, text, or tables; check out the cheatsheet for Output() functions. In essence, these are placeholders, which will be filled in based on what we define in our server. Similar to inputs, we must also specify an inputID as the first argument. Read more! 4.3 Server On the server side, we build the logic that will power our app. Specifically, we need to fill our outputs and link them to the corresponding inputs if required. We do this by using a different suite of functions that will dictate what we fill our outputs with and the reactivity elements. These will all be connected using the input and output IDs that we set up in our UI. 4.3.1 Inputs Inputs are essentially data sent from the browser (ie. UI) to the server, which can be accessed by calling input$inputID. Because these are dictated on the browser side, these values are not modifiable (ie. they are read-only) within the server. The other important point about inputs is we inherently want to use them in a reactive context; in other words, we want to have logic that reacts to user input to drive behaviour on the backend. More on this in section @(react). Read more! 4.3.2 Outputs Similar to inputs we refer to outputs using their output IDs by calling output$outputID. However, as you may have guessed, instead of receiving inputs from the browser, we are providing outputs to fill in the UI placeholders. Outputs are always created using render functions, these may be in in reactive statements, which may change depending on inputs or they can be stand alone outputs that arent connected to any inputs. Read more! 4.3.3 Reactivity Reactivity is what brings everything together in an app. This is where we can use user inputs to update UI and outputs automatically. Reactive functions from shiny have many options for how they update things, you can make UI and ouputs update in real time, when you click a button, or under other conditions! This is called declarative programming when you set certain constraints and let the program (our app) determine when to execute under those constraints. Interestingly, shiny operates lazily, in other words, it will only do the minimum work required to get the job done and only when it has to. We are basically telling shiny to: Ensure there is a sandwich in the refrigerator whenever I look inside of it In the above diagram the name is our input, the string is our reactive function driving behaviour on the backend, and the greeting is our output! Read more! 4.3.4 Execution order Prepare yourself, this is where we begin to flip all of our coding knowledge on its head. Unlike regular scripts where we expect R to execute things orderly, line by line, shiny server logic doesnt function this way.. Instead, shiny will only execute specific lines of the server when it has what it needs for that line. With that being said, its still recommended to have things in order to avoid confusion. But I think its an important thing to realize, because it highlights what is truly going on in the background and what makes shiny lazy. NOTE This: server &lt;- function(input, output, session) { output$greeting &lt;- renderText(string()) string &lt;- reactive(paste0(&quot;Hello &quot;, input$name, &quot;!&quot;)) } is the same as this: server &lt;- function(input, output, session) { string &lt;- reactive(paste0(&quot;Hello &quot;, input$name, &quot;!&quot;)) output$greeting &lt;- renderText(string()) } 4.4 Dynamic UI We wont dive too deeply into dynamic UI elements. They essentially function as typical UI inputs, however, they can be updated by other inputs to update in a reactive function similar to how we can use inputs to update outputs, except in this case the output is a UI element. Read more! 4.5 Basic example 4.5.1 Set up First we need to do some prep before we build our app. Lets load a dataset and our libraries: library(shiny) library(bslib) library(datasets) 4.5.2 Build the UI 4.5.3 Build the server 4.5.4 Putting it all together 4.6 Deploying your app 4.7 Packaging a Shiny App Using package structure for a shiny app gets your toes into the water of package development. Its a long way from a complete package, but its still useful because it activates new tools that make it easier to work with larger app and provides you with standard conventions that can be used across projects. 4.7.1 Put all R code in the R/ directory Because we are going to be working in an app-package we need to create an R/ directory. This is where we will keep all of the core R code components that will build our app. As a reminder, in a package we are leveraging useful tools like devtools::load_all() (See section 3.3), which will go into the R/ directory and load/run all of the code within this directory. 4.7.2 Write a function that starts your app As mentioned in section @(app-structure), we need three primary pieces to create an app: ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) Now, to begin converting our project to a package-app we must wrap this into a function: myApp &lt;- function(...) { ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) } NOTE The function you create shouldnt need any arguments, all that we will use this for is to easily run our app locally and set it up for easy deployment later. 4.7.3 Save your data to the data/ directory We may have some datasets or lists that we use in our app that arent routinely updated. These are perfect candidates to convert into .rda files using the handy function usethis::use_data() that we talked about in section 3.9. These will automatically be stored in the data/ directory and can be easily called directly after running load_all(). 4.7.4 Create an inst/ directory The inst/ directory is where we can store other raw datasets that are more subject to change, for example the data used to feed our apps that comes from external pipelines. There is no standard convention so you can name things as you please, but common usage includes folders named inst/extdata or inst/ext to store these datasets. NOTE Load data with read.csv(system.file(\"exdata\", \"mydata.csv\", package = \"myApp\")). Notice that our package-app automatically knows to look in our inst/ folder? myApp &lt;- function(...) { read.csv(system.file(&quot;extdata&quot;, &quot;mydata.csv&quot;, package = &quot;myApp&quot;)) ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) } 4.7.5 Create a www/ directory This directory is where you can store some of the other non-script or data components to the app such as CSS stylings or images. There are no rules to this but a suggestion would be to have a www/css and www/images sub-directory scheme for your app. TIP If you want to call files from within these sub-directories (eg. href = \"css/style.css\") you will need to tell your app where they are: myApp &lt;- function(...) { shiny::addResourcePath(&quot;css&quot;, file.path(getwd(), &quot;www/css&quot;)) shiny::addResourcePath(&quot;images&quot;, file.path(getwd(), &quot;www/images&quot;)) ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) } 4.7.6 Create a DESCRIPTION file Because we are working in a package environment one of the critical components will be our DESCRIPTION file, which was discussed in section 3.4. Dont forget to set your dependencies! 4.7.7 Deploying your app-package One of the final pieces to setting up your app-package is the app.R script. This is what will be used when we go to deploy our app to the server and contains two simple but important lines of code: pkgload::load_all(&quot;.&quot;) myApp() WARNING Although this is an R script, we DO NOT place this under our R/ directory. This would result in an infinite loop when loading due to our load_all() function! Therefore place this at the top-level of your project directory. Normally when you deploy an app, the rsconnect package automatically figures out all of the packages your code uses. But now that you have a DESCRIPTION file, it requires you to explicitly specify them. The easiest way to do this is to call usethis::use_package(). Youll need to start with shiny and pkgload: usethis::use_package(&quot;shiny&quot;) usethis::use_package(&quot;pkgload&quot;) Read more! 4.7.8 Workflow Putting your app code into the package structure unlocks a new workflow: Re-load all code in the app with Cmd/Ctrl + Shift + L. This calls devtools::load_all() which automatically saves all open files, source()s every file in R/, loads all datasets in data/ then puts your cursor in the console. Re-run the app with myApp(). Read more! 4.8 Additional Resources Shiny Manual Shiny Cheatsheet "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
