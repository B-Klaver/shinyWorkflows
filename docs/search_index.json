[["index.html", "Shiny App Workflows Preface", " Shiny App Workflows Braeden Klaver 2025-03-13 Preface This document aims to provide a walkthrough on how to work within a shiny app workflow that leverages git/gitlab, package structure, shiny, and bslib. "],["git.html", "1 Git 1.1 Basic git workflow 1.2 Setting up Github or Gitlab projects 1.3 Collaborative git workflow 1.4 Using Git at the BCCDC 1.5 Basic Git Commands Summary 1.6 Additional Resources", " 1 Git Git is a free and open-source version control system. When used regularly and as intended, developers will have a full history of their project within a local repository. In addition to a historical log of changes to project files, git allows for project branching to support users to test/develop new code, while maintaining the master version for easy reversion. When users are ready to implement their new branch into the main codebase git can be used for merging files, whereby it tracks changes and ensures there are no conflicts between the main version and the new version. Beyond local usage, git is also supported by web-based repositories such as Github and Gitlab, where projects can be pushed, pulled, and cloned. These sites allow for easy collaboration with other developers and provide a number of user-friendly features that make working with git easier. NOTE In RStudio, git is accessed in the terminal or in the top right under the Git tab when Git has been initialized for the project. 1.1 Basic git workflow Step 1) Create a project. Step 2) Initialize git. git init Step 3) Check your project file status git status Step 4) Add a file to the local repo git add filename.R Step 5) Commit your change with a message git commit -m \"Add filename.R\" Step 6) Create a branch to test/develop code git branch test_branch Step 7) Go into that branch git checkout test_branch Step 8) Modify your code and repeat steps 3 and 4 Step 9) When ready merge branches git merge master test_branch TIP Branching is useful when you have a stable codebase that you do not want to break or if you are working collaboratively on a code base. You can create a branch to do development work and test new features until its ready for integration with the stable codebase or your coworkers. If you are developing something from scratch by yourself you may not need to use branching until later. 1.2 Setting up Github or Gitlab projects Ensure your profile is set up git config --global user.name \"Braeden Klaver\" git config --global user.email \"braeden.klaver@bccdc.ca\" 1.2.1 Pre-existing project on Github or Gitlab Step 1) In your terminal navigate to the folder you want to clone the project to cd \"U:/myprojects\" Step 2) Clone the project into that folder and give the project a name git clone http://lvmgenodh01.phsabc.ehcnet.ca/braeden.klaver/test.git myproject 1.2.2 Personal project without git Step 1) Open your R project Step 2) Initialize git git init Step 3) Create a project on Gitlab or Github Step 4) Connect your R project to that repository (should be the URL) git remote add origin http://lvmgenodh01.phsabc.ehcnet.ca/braeden.klaver/test.git Step 5) Add and commit your files git add . git commit -m \"Initial commit\" Step 6) Push your project to that repository git push 1.2.3 Personal project with Git Step 1) Open your R project Step 2) Connect your R project to that repository (should be the URL) git remote add origin http://lvmgenodh01.phsabc.ehcnet.ca/braeden.klaver/test.git Step 3) Push your project to that repository git push 1.3 Collaborative git workflow In addition to the basic workflow, when working with a web-based repository like Github or Gitlab there are additional steps you will need to take: Step 1) Pulling changes from the repository - your coworkers may have made changes! git pull Step 2) Follow the basic workflow (Section 1.1) Step 3) Pushing your changes to the repository - your coworkers will want to be up to date! git push 1.4 Using Git at the BCCDC 1.4.1 Git on Citrix Git is installed on citrix already, it can be initialized as described above or you can click a check box to create a git repository when creating a new project. TIP If you have a local R installation and youd like to work there but do not have git installed locally you can still leverage citrix R to use git for your projects. 1.4.2 Git locally If you want to use Git locally you will need to install it for your system. Typically, this will be the 64-bit windows version found here. Once it is downloaded you should be able to use git as described above in your local RStudio. NOTE The benefits of having a local installation of git is that if you primarily use your local RStudio you can access it directly through there rather than jumping to citrix. Additionally, you can use it to connect to repositories in Github, which is not possible on citrix. 1.4.3 Github Because Github is an external web-based repository there are some considerations for its use at the BCCDC. Currently, there are no formal guidelines on using it, for this reason using it for BCCDC-specific projects should be avoided. 1.4.4 Gitlab The BCCDC has a private Gitlab repository, which can be used for regular BCCDC projects within the scope set out in the guiding document. NOTE You can request access to Gitlab via this form. 1.4.5 Suggested project workflow Working with git tracked projects requires you to have your own local repository. For this reason, it is recommended to keep this repository in your U:/ drive. In addition, we would recommend having another local repository in the O:/ drive, which would be dedicated to running pipelines or deploying apps and not for development work. WARNING Some project data may not be permitted on your U:/ drive, therefore ensure your code is loading that data from an appropriate location. 1.5 Basic Git Commands Summary Command Description git init Initialize git for the directory git status Check the status of files in the directory (eg. are they being tracked, have they been modified) git add Stage a file for commit git rm Remove a file staged for commit git commit Commit your changes git branch Create a branch for development work git checkout Checkout a branch to work within git merge Merge two branches together git pull Pull the most up-to-date repository from a remote (ie. Github or Gitlab) git push Push your changes to a remote repository (ie. Github or Gitlab) NOTE There are many other functions that you can use in git beyond those listed above, however, these give you the tools to get started. 1.6 Additional Resources Mike Kuos Git Tutorial Git Playground "],["package-development.html", "2 Package Development 2.1 Package Structure 2.2 Loading devtools and usethis 2.3 load_all function 2.4 The DESCRIPTION file 2.5 Documenting your functions 2.6 The NAMESPACE 2.7 The README file 2.8 Organizing your scripts 2.9 Using data in a package 2.10 Additional Resources", " 2 Package Development In R, the fundamental unit of shareable code is the package. A package bundles together code, data, documentation, and tests, and is easy to share with others. But packages are useful even if you never share your code. As Hilary Parker says in her introduction to packages: Seriously, it doesnt have to be about sharing your code (although that is an added benefit!). It is about saving yourself time. Organising code in a package makes your life easier because packages come with conventions. For example, you put R code in R/, you put tests in tests/ and you put data in data/. These conventions are helpful because: They save time  you dont need to think about the best way to organise a project, you can just follow a template. Standardised conventions lead to standardised tools  if you buy into Rs package conventions, you get many tools for free. 2.1 Package Structure In an R package or R project structured as a package the typical files and folders will be (locally, you can consult your Files pane): path type description .Rbuildignore file Lists files that we need to have around but that should not be included when building the R package from source. .gitignore file Tells Git to ignore some standard, behind-the-scenes files created by R and RStudio. DESCRIPTION file Provides metadata about your package. NAMESPACE file Declares the functions your package exports for external use and the external functions your package imports from other packages. R/ folder the business end of your package. It will soon contain .R files with function definitions. 2.2 Loading devtools and usethis The devtools package is fundamental for developing packages, it comes with a suite of incredibly powerful functions. In addition, it comes with the required package usethis, which compliments the devtools package with another suite of functions required to properly build packages. library(devtools) 2.3 load_all function In a package or project structured as a package you are typically making functions that are stored in the R/ folder. In a standard project you may be familiar with the use of source(\"R/myfunction.R\") to load or run a script. However, devtools allows us to easily run/load all of our project contents with one simple function call: devtools::load_all() This does a few main things: Loads/runs your scripts located in the R/ folder Loads data stored in your data folder Loads other package objects Loads package dependencies listed in the DESCRIPTION file NOTE One main difference is that these functions and data that have been loaded will not appear in the environment, even though they are available. This is similar to when we load a package, such as library(tidyverse), we are now able to use functions such as mutate even though they dont appear in our environment. 2.4 The DESCRIPTION file The DESCRIPTION file provides metadata for your package. Some key pieces of this metadata include the description of the project and the dependencies. If your project doesnt have a DESCRIPTION file you can easily add one using usethis: usethis::use_description() You can manually edit this file or alternatively add certain elements using usethis. For example adding dependencies: usethis::use_package(&#39;dplyr&#39;) NOTE After creating a DESCRIPTION file in your project you will automatically enter package development mode. Read more! 2.5 Documenting your functions At some point we have all used the help functions in R by easily calling something like ?mutate. This requires special documentation which is stored in path such as man/mutate within the package. To do this for ourselves we have to use something called roxygen2, which helps create these handy help windows. To do this with your functions you can open your function script, place the cursor somewhere within the function and then do Code &gt; Insert roxygen skeleton, which will create a basic skeleton to fill out such as this: #&#39; Split a string #&#39; #&#39; @param x A character vector with one element. #&#39; @param split What to split on. #&#39; #&#39; @return A character vector. #&#39; @export #&#39; #&#39; @examples #&#39; x &lt;- &quot;alfa,bravo,charlie,delta&quot; #&#39; strsplit1(x, split = &quot;,&quot;) strsplit1 &lt;- function(x, split) { strsplit(x, split = split)[[1]] } Now, one more step is needed. We must use devtools to automatically create that man/function and update our NAMESPACE file like so: devtools::document() Read more! 2.6 The NAMESPACE The NAMESPACE file is an automatically generated and maintaind file by R, this should not be manually modified. It is filled out depending on the roxygen2 comments left in your scripts and is updated, as described above, by using devtools::document(). It informs the package what contents should be exported when building the package, as well as what needs to be imported (package dependencies) for the package to run. Read more! 2.7 The README file The README file is a very useful document that can help provide context, general information, and usage insight to users. In addition, when knitted, README files are formatted to appear as nice markdown documents in Github and Gitlab. To get a README file started in a project all that you need to do is: usethis::use_readme_rmd() NOTE Remember, you have to knit your README in order to produce a .md file version of it, which will be directly used in places like Github or Gitlab. 2.8 Organizing your scripts The file name should be meaningful and convey which functions are defined within. While youre free to arrange functions into files as you wish, the two extremes are bad: dont put all functions into one file and dont put each function into its own separate file. Organizing.principle Comments One function Defines exactly one function, thats not particulary large, but doesnt fit naturally into any other .R file Main function plus helpers Defines the user-facing function, a method, and private helpers Family of functions Defines a family of functions, all documented together in a big help topic, plus private helpers TIP Another file you often see in the wild is R/utils.R. This is a common place to define small utilities that are used inside multiple package functions. Since they serve as helpers to multiple functions, placing them in R/utils.R makes them easier to re-discover when you return to your package after a long break. 2.9 Using data in a package Traditionally, data in a package is stored in the data/ folder. The data there will be saved in a specific data form that will make it available when you run devtools::load_all(). To store data within a package like this you need to run: usethis::use_data(df) 2.10 Additional Resources R Package Manual "],["shiny.html", "3 Shiny 3.1 Shiny App Structure 3.2 UI 3.3 Server 3.4 Dynamic UI 3.5 Basic example 3.6 Deploying your app 3.7 Packaging a Shiny App 3.8 Additional Resources", " 3 Shiny If youve never used Shiny before, welcome! Shiny is an R package that allows you to easily create rich, interactive web apps. Shiny allows you to take your work in R and expose it via a web browser so that anyone can use it. Shiny makes you look awesome by making it easy to produce polished web apps with a minimum amount of pain. 3.1 Shiny App Structure Shiny apps are composed of two main elements. The UI: This is where you define the layout and appearance of your app, including sliders, plots, tabs, etc. The server: This is where you connect your UI components using logic behind the scenes to drive app behaviour. These two elements are operationalized by calling shinyApp(ui = ui, server = server) 3.2 UI 3.2.1 Setting up the UI TO create a shiny app you must create a UI. Traditionally, in shiny you would do this using the function fluidPage(). The UI will contain elements such as calls to CSS stylings, overall UI design, inputs, and outputs. 3.2.2 Layout and themes In the UI one of the main things you will do is to set up the general look of the app. You can do this using elements such as layouts, which you can use to create sidebars, panels/tabs, and columns. Beyond the layout, you can also set a theme for your app. Currently, the easiest way to do this is to use the bslib package and set the theme by calling bslib::bs_theme(). There are a number of preset themes you can use, but you are also free to customize your own theme using this function. You can further tweak your apps look by using custom CSS stylings and by incorporating html code into your UI call. Read more! 3.2.3 Inputs There are a number of inputs that are incredibly useful in shiny apps such as radioButtons(), selectInput(), actionButton(), and dateRangeInput(). These allow users to interact with our app to dictate what appears in our app. These functions all share a two main arguments: inputID: This is the identifier used to connect the front end with the back end: if your UI has an input with ID name, the server function will access it with input$name. label: This is used to create a human-readable label for the control (ie. Select Geography). NOTE The inputId has two constraints: It must be a simple string that contains only letters, numbers, and underscores (no spaces, dashes, periods, or other special characters allowed!). Name it like you would name a variable in R. It must be unique. If its not unique, youll have no way to refer to this control in your server function! Read more! 3.2.4 Outputs In the UI we can also specify the outputs that wed like to include, for example plots, text, or tables. In essence, these are placeholders, which will be filled in based on what we define in our server. Similar to inputs, we must also specify an inputID as the first argument. Read more! 3.3 Server On the server side, we build the logic that will power our app. Specifically, we need to build the reactivity aspect of our app. We do this by using a different suite of functions that will dictate the reactivity, which will utilize the inputs and outputs we set up in our UI. 3.3.1 Inputs Inputs are essentially data sent from the browser (ie. UI) to the server, which can be accessed by calling input$inputID. Because these are dictated on the browser side, these values are not modifiable within the server - it wouldnt make sense if a user chose Fraser Health and we had logic on the server than turned this into Interior Health. The other important point about inputs is we inherently want to use them in a reactive context (ie. we want to have logic that reacts to user input). For this reason, we must use the reactivity aspect of our UI to modify outputs accordingly. Read more! 3.3.2 Outputs Similar to inputs we refer to outputs using their output IDs by calling output$outputID. However, unlike inputs we arent receiving user inputs we are pushing outputs. Outputs are always created using render functions, these may be in in reactive statements and can change depending on inputs or they can be stand alone outputs that arent connected to any inputs. Read more! 3.3.3 Reactivity Reactivity is what brings everything together in an app. This is where we can use user inputs to update UI and outputs automatically. Reactive functions from shiny have many options for how they update things, you can make UI and ouputs update in real time, when you click a button, or under other conditions! This is called declarative programming when you set certain constraints and let the program (our app) determine when to execute under those constraints. Interestingly, shiny operates lazily, in other words, it will only do the minimum work required to get the job done and only when it has to. We are basically telling shiny to: Ensure there is a sandwich in the refrigerator whenever I look inside of it Read more! 3.3.4 Execution order Prepare yourself, this is where we begin to flip all of our coding knowledge on its head. Unlike regular scripts where we expect R to execute things orderly, line by line, shiny server logic doesnt function this way.. Instead, shiny will only execute specific lines of the server when it has what it needs for that line. With that being said, its still recommended to have things in order to avoid confusion. But I think its an important thing to realize, because it highlights what is truly going on in the background and what makes shiny lazy. NOTE This: server &lt;- function(input, output, session) { output$greeting &lt;- renderText(string()) string &lt;- reactive(paste0(&quot;Hello &quot;, input$name, &quot;!&quot;)) } is the same as this: server &lt;- function(input, output, session) { string &lt;- reactive(paste0(&quot;Hello &quot;, input$name, &quot;!&quot;)) output$greeting &lt;- renderText(string()) } 3.4 Dynamic UI We wont dive too deeply into dynamic UI elements. They essentially function as typical UI inputs, however, they can be updated by other inputs to update in a reactive function similar to how we can use inputs to update outputs, except in this case the output is a UI element. Read more! 3.5 Basic example 3.5.1 Set up First we need to do some prep before we build our app. Lets load a dataset and our libraries: library(shiny) library(bslib) library(datasets) 3.5.2 Build the UI 3.5.3 Build the server 3.5.4 Putting it all together 3.6 Deploying your app 3.7 Packaging a Shiny App Using package structure for a shiny app gets your toes into the water of package development. Its a long way from a complete package, but its still useful because it activates new tools that make it easier to work with larger app and provides you with standard conventions that can be used across projects. 3.7.1 Put all R code in the R/ directory Because we are going to be working in an app-package we need to create an R/ directory. This is where we will keep all of the core R code components that will build our app. As a reminder, in a package we are leveraging useful tools like devtools::load_all() (See section 2.3), which will go into the R/ directory and load/run all of the code within this directory. 3.7.2 Write a function that starts your app As mentioned in section (LINK HERE), we need three primary pieces to create an app: ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) Now, to begin converting our project to a package-app we must wrap this into a function: myApp &lt;- function(...) { ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) } NOTE The function you create shouldnt need any arguments, all that we will use this for is to easily run our app locally and set it up for easy deployment later. 3.7.3 Save your data to the data/ directory We may have some datasets or lists that we use in our app that arent routinely updated. These are perfect candidates to convert into .rda files using the handy function usethis::use_data() that we talked about in section 2.9. These will automatically be stored in the data/ directory and can be easily called directly after running load_all(). 3.7.4 Create an inst/ directory The inst/ directory is where we can store other raw datasets that are more subject to change, for example the data used to feed our apps that comes from external pipelines. There is no standard convention so you can name things as you please, but common usage includes folders named inst/extdata or inst/ext to store these datasets. NOTE Load data with read.csv(system.file(\"exdata\", \"mydata.csv\", package = \"myApp\")). Notice that our package-app automatically knows to look in our inst/ folder? myApp &lt;- function(...) { read.csv(system.file(&quot;extdata&quot;, &quot;mydata.csv&quot;, package = &quot;myApp&quot;)) ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) } 3.7.5 Create a www/ directory This directory is where you can store some of the other non-script or data components to the app such as CSS stylings or images. There are no rules to this but a suggestion would be to have a www/css and www/images sub-directory scheme for your app. TIP If you want to call files from within these sub-directories (eg. href = \"css/style.css\") you will need to tell your app where they are: myApp &lt;- function(...) { shiny::addResourcePath(&quot;css&quot;, file.path(getwd(), &quot;www/css&quot;)) shiny::addResourcePath(&quot;images&quot;, file.path(getwd(), &quot;www/images&quot;)) ui &lt;- fluidPage( ... ) server &lt;- function(input, output, session) { ... } shinyApp(ui, server, ...) } 3.7.6 Create a DESCRIPTION file Because we are working in a package environment one of the critical components will be our DESCRIPTION file, which was discussed in section 2.4. Dont forget to set your dependencies! 3.7.7 Deploying your app-package One of the final pieces to setting up your app-package is the app.R script. This is what will be used when we go to deploy our app to the server and contains two simple but important lines of code: pkgload::load_all(&quot;.&quot;) myApp() WARNING Although this is an R script, we DO NOT place this under our R/ directory. This would result in an infinite loop when loading due to our load_all() function! Therefore place this at the top-level of your project directory. Normally when you deploy an app, the rsconnect package automatically figures out all of the packages your code uses. But now that you have a DESCRIPTION file, it requires you to explicitly specify them. The easiest way to do this is to call usethis::use_package(). Youll need to start with shiny and pkgload: usethis::use_package(&quot;shiny&quot;) usethis::use_package(&quot;pkgload&quot;) Read more! 3.7.8 Workflow Putting your app code into the package structure unlocks a new workflow: Re-load all code in the app with Cmd/Ctrl + Shift + L. This calls devtools::load_all() which automatically saves all open files, source()s every file in R/, loads all datasets in data/ then puts your cursor in the console. Re-run the app with myApp(). Read more! 3.8 Additional Resources Shiny Manual Shiny Cheatsheet "],["bslib.html", "4 bslib 4.1 ", " 4 bslib 4.1 . "],["modularization.html", "5 Modularization 5.1 ", " 5 Modularization 5.1 . "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
